### redis为什么是单线程的?

redis是一个基于内存的数据库, 还要处理大量的外部网络请求, 这就不可避免的要进行多次IO

1. IO多路复用

   <img src="E:\learningNotes\Redis\image-20210104172712670.png" alt="image-20210104172712670" style="zoom: 67%;" />

   FD是一个文件描述符, 表示当前文件处于可读, 可写, 还是异常状态. 使用IO多路复用机制同时监听多个文件描述符的可读和可写状态.一旦受到网络请求就会在内存中快速处理, 由于绝大多数的操作都是纯内存的, 所以处理的速度会非常快. 也就是说在单线程模型下, 即使连接的网络处理很多, 因为有IO多路复用, 依然可以在告诉的内存中得到忽略.

2. 可维护性高

   多线程模型虽然在某些方面表现优异, 但是却引入了程序执行的不确定性, 带来了并发读写的问题.而单线程模型下可以方便的进行调试和测试

3. 基于内存, 单线程状态下效率依然很高

   多线程可以充分的利用CPU资源, 但是对于redis来说, 由于内存速度很快, 能达到一秒之内处理10万个用户请求, 如果这个还不够我们可以使用redis分片技术将请求交给不同的redis服务器. 这样的做法避免了在同一个redis服务中引入大量的线程操作.

   而且由于redis基于内存, 所以除非是进行AOF备份, 否则不会涉及到任何的IO操作.这些数据的读写由于只发生在内存中, 所以处理速度非常快; 用多线程模型处理全部的外部请求不见得是一个很好的方案.



> 总结: redis基于内存而且使用多路复用技术, 单线程速度很快, 又保证了多线程的特点, 因此没必要使用多线程.



### 为什么引入多线程

读写网络的read/write系统调用在redis执行期间占用了大部分的CPU时间, 如果把网络读写做成多线程的额方式会对性能得到很大的提升.

redis的多线程部分只是用来处理网络数据的读写和协议解析, 执行命令仍然是单线程. 之所以这么设计是不想redis因为多线程因为多线程而变的复杂, 需要去控制并发问题.

redis加入了一些可以被其他线程异步处理的删除任务, 也就是 UNLINK、FLUSHALL ASYNC 和 FLUSHDB ASYNC.我们知道redis可以使用del命令删除一个元素, 如果这个元素很大, 可能占据了几十兆或者是几百兆, 那么在短时间内是不能完成的, 这就需要多线程的异步支持.

> 总结:
>
> redis使用单线程模型处理客户端的请求主要还是因为cpu不是redis的瓶颈, 所以使用多线程模型带来的性能提升并不能抵消他带来的开发成本和维护成本, 系统的性能瓶颈也主要是在网络IO操作上; 而redis引入多线程操作也是出于性能上的考虑, 对于一些大键值对的删除操作, 通过多线程非阻塞的释放内存空间也能减少redis主线程阻塞的时间, 提高执行效率.