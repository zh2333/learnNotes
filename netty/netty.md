# Netty



### 网络IO模型

#### 同步和异步, 阻塞和非阻塞

- 同步和异步

  关注结果的通知机制

  **如果结果是自己主动去获取的, 那就是同步**

  **如果结果是别人通知自己的, 那就是异步**

  同步主动等待结果的返回  ====> 自己主动等待获取结果

  异步不主动等待结果的返回 =====>  回调 , 别人通知我结果

- 阻塞和非阻塞

  关注任务的并发度, 即在执行获取结果任务的同时是否在干别的事情

  **如果除了等待结果什么事也不敢, 那就是阻塞**

  **如果除了等待结果, 也可以去执行别的任务, 那就是非阻塞**

  阻塞       =====>  单线程, 串行

  非阻塞   =====>  多线程, 子线程等待, 主线程去干别的事

- 同步阻塞

  **结果是自己主动获取的, 且在结果没出来时别的事情不做, 只等待结果**

- 同步非阻塞

  **结果是自己获取的, 但是在结果还没出来时, 去做别的事情, 每过一段时间就来看看结果出没出来**

  相当于轮询

- 异步阻塞

  **别人通知我结果, 但是在别人通知我之前, 我什么也不做**

- 异步非阻塞

  **别人通知我获取结果, 且在别人通知我之前, 我还可以去做别的事情**



####  Linux下的5中IO模型

1. 阻塞IO   =====>  **用在客户端**) 

   ![image-20200816141230405](E:\learningNotes\netty\pic\image-20200816141230405.png)

   recvfrom, 用户进程会等待内核将网卡数据从内核空间拷贝到用户空间才会返回

2. 非阻塞IO

   ![image-20200816141455617](E:\learningNotes\netty\pic\image-20200816141455617.png)

   非阻塞IO通过进程反复调用IO函数来实现(非常消耗CPU, 这种IO模型很少用)

   但是在数据拷贝的过程中, 用户进程仍然是阻塞的

3. IO复用(**select, poll 和epoll**) ===> **用在服务器**

   ![image-20200816141819551](E:\learningNotes\netty\pic\image-20200816141819551.png)

   select会轮询socket(不管socket有没有数据都会检查)

   select和poll: 对于一个socket来说, 两次调用, 两次返回, 比阻塞IO并没有什么优越性; 关键是能实现同时对多个socket进行处理

4. 信号驱动(很少用)

   ![image-20200816141959017](E:\learningNotes\netty\pic\image-20200816141959017.png)

5. 异步IO(**未来的发展趋势**)  目前实现异步IO的只有IOCP(Windows下)

   ![image-20200816142011806](E:\learningNotes\netty\pic\image-20200816142011806.png)

   当应用程序需要数据时, 会发出一个异步过程调用, 但是调用者不能立刻获得结果, 它可以先去干别的事情

   实际是内核在负责处理数据, 内核将数据读出并从内核空间拷贝到用户空间后就会通知应用程序, 其所需要的数据已经准备好了

6. 比较

   ![image-20200816142613342](E:\learningNotes\netty\pic\image-20200816142613342.png)

   select, poll和epoll区别?

   select在打开的连接数上有限制, poll和epoll没有1024的限制

   select和poll会将所有的socket都检查一遍, epoll只会对活跃的socket检查

   select和poll需要将数据从内核空间拷贝到用户空间, epoll实现中没有拷贝这个操作了, 因为在后者的实现中, 内核空间和用户空间会共享一段内存



### 原生JDK网络编程

#### BIO编程

服务端使用ServerSocket  负责绑定IP地址, 端口号

socket负责建立连接

1. 客户端没来一个请求, 服务器端就要新建一个线程负责这个连接

   ![image-20200816144706214](E:\learningNotes\netty\pic\image-20200816144706214.png)

2. 当用户请求来了之后将用户请求打包成任务放到线程池中, 减少了线程的开销, 但是如果请求数太多, 用户的任务会等待

   ![image-20200816144717375](E:\learningNotes\netty\pic\image-20200816144717375.png)



#### AIO编程

在JDK中实现异步编程需要实现ComplementionHandler接口, 内核在完成数据的读取和拷贝后会主动通知实现了该接口的函数

异步IO采用, 订阅-通知模式

即应用程序向操作系统注册IO监听, 然后继续做自己的事情.当操作系统发生IO事件并且准备好数据后, 再主动通知应用程序







### Netty  ===> 基于epoll

Netty是一个java开源框架.提供异步的, 事件驱动的网络应用程序框架和工具, 泳衣快速开发搞性能, 高可靠的网络服务器和客户端程序



#### 第一个Netty程序

1. 核心组件

   - Channel

     传入和传出数据的通道

   - 回调和future

     回调就是一个函数

     future 在操作完成后通知应用程序的方式(异步操作结果的**占位符**), 继承了JDK的future接口

   - 事件和Channelhandler

   ![image-20200816162442433](E:\learningNotes\netty\pic\image-20200816162442433.png)

   ​	事件, 

   入站事件 

   和出站事件 打开或者关闭连接, flush

   当事件发生后, 事件就会被分发给ChannelHandler去处理

   



