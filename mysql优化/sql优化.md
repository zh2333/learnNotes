## mysql优化



### 索引

索引是帮助mysql高效获取数据的排好序的数据结构

> 索引数据结构:
>
> 1. 二叉树
>
>    ![image-20200905173519623](E:\learningNotes\mysql优化\pic\image-20200905173519623.png)
>
>    不适合作为索引, 当数据单向变化时, 二叉树就退化为单链表, 效率和全表扫描的效率一样
>
> 2. 红黑树
>
>    解决了二叉树的问题, 但是仍然不适用. 几百万的数据都存在红黑树中, 红黑树的高度仍然会很高.当数据量很大时, 树的高度不可控
>
> 3. hash表
>
>    ![image-20200905184448812](E:\learningNotes\mysql优化\pic\image-20200905184448812.png)
>
>    * 对索引的key进行一次hash计算就可以定位出数据存储的位置
>
>    * 很多时候hash索引要比B+树更高效
>
>    * **仅仅能满足 "=", "IN" , 不支持范围查询**. B+树支持范围查找, 因为其有双向链表
>
>    * hash冲突问题
>
> 4. B-Tree
>
>    ![image-20200905185003330](E:\learningNotes\mysql优化\pic\image-20200905185003330.png)
>
>    * 叶节点具有相同的深度, 叶子节点的指针为空
>    * 所有索引元素不重复
>    * 节点中的数据索引从左向右递增
>
> 5. B+ 树
>
>    实际上是一种多叉平衡树
>
>    ![image-20200905174914653](E:\learningNotes\mysql优化\pic\image-20200905174914653.png)
>
>    * mysql底层采用的是B+树
>    * 非叶子节点不存储data, 值存储索引, 因此一个非叶子节点可以存放更多的索引
>    * 叶子节点包含所有索引字段
>    * 叶子节点用指针连接, 提高区间访问的性能
>    * 一个节点就是一页数据.mysql底层设置的一页数据的大小是16384Byte, 三层的B+树, 他最多可以存储的数据量是 一千多万



### 存储引擎

mysql的存储引擎有两个, MySImhe 和InnoDb, 两个数据库引擎的文件存储格式是不一样的

![image-20200905180601888](E:\learningNotes\mysql优化\pic\image-20200905180601888.png)

InnoDB主要由两个文件组成, frm文件存储的是表的结构信息, ibd文件存储的是表的索引以及表数据

![image-20200905181241774](E:\learningNotes\mysql优化\pic\image-20200905181241774.png)

InnoDB主要用于**聚集索引**

* 表数据文件本身就是按照B+树组织的一个索引结构文件

* 聚集索引-叶节点包含了完整的数据记录

* 为什么建议InnoDB必须建主键, 并且推荐使用整型的自增主键?

  如果没有建主键, 即灭有主键索引, 那么如何数据呢?mysql会首先查找数据都唯一的一列作为主键索引, 如果没有找到这样的列, 那么mysql会自动建一个隐藏列来将表中所有的数据维护到B+树中

  整型可以轻松的比较, 尽量不要使用UUID, 整型占用的空间比UUID更少

  自增可以保证主键唯一. 如果不是非自增的, 会要先找到在非叶子节点中的插入位置

* 为什么非主键索引结构叶子节点存储的是主键值(一致性和节省存储空间)

MySim主要由三个文件组成, frm文件存储的是表的结构, MYD存储的是表数据, MYI存储的是索引信息

MySIm主要用于**非聚集索引**

![image-20200905182511725](E:\learningNotes\mysql优化\pic\image-20200905182511725.png)

MYSIM的查找过程

![image-20200905180333176](E:\learningNotes\mysql优化\pic\image-20200905180333176.png)

> 不支持事务, 不支持行锁



### 联合索引

#### 1.底层结构

![image-20200906101142905](E:\learningNotes\mysql优化\pic\image-20200906101142905.png)



> 如何排序?
>
> 按照字段建立的先后顺序, 比如上图中, 先比较name, 如果按照name就可以排序, 那么接下来两个字段都不会比较. 如果name相等就按照age排序, 如果age相等就按照position排序



##### 最左前缀原则

![image-20200906102056737](E:\learningNotes\mysql优化\pic\image-20200906102056737.png)

第一条会走索引, 而后面两条不会走索引. 这就是最左前缀原则, 不能跳过联合索引的第一个字段

**实现机制**

联合索引是默认按照第一个字段进行排序, 如果跳过第一个字段, 用age走索引, 其查询到的数据在一定范围内不是有序的， 仍然需要全表查找. 索引是什么? 索引就是排好序的数据结构呀, 如果无序那么建立索引的意义何在呢。

![image-20200906102521968](E:\learningNotes\mysql优化\pic\image-20200906102521968.png)



