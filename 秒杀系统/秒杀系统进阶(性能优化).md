# 秒杀系统性能优化

知识点

![image-20200417195859501](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417195859501.png)



### 性能压测框架

1. SpringBoot云端部署
2. 使用JMeter发现性能问题

### 分布式扩展

1. Nginx反向代理负载均衡
2. 分布式会话管理

### 查询优化技术之多级缓存

1. 多级缓存设计原理
2. Redis华黁,本地缓存
3. 热点Nginx Lua缓存

### 查询优化技术之页面静态化

1. 静态请求CDN原理
2. 静态请求CDN应用
3. PhantomJS商品详情全页面静态化

### 交易优化技术之缓存库存

1. 交易缓存验证技术
2. 缓存库存模型

### 交易优化技术之事务型消息

1. 事务型消息解决最终一致性
2. 库存售罄防击穿优化

### 流量错峰技术

1. 秒杀令牌
2. 秒杀大闸
3. 队列泄洪

### 放刷限流

1. 验证码
2. 限流器
3. 防黄牛

### 实验环境

![image-20200417200857702](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417200857702.png)



### 项目回顾

三层模型

![image-20200417201541134](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417201541134.png)

![image-20200417201946361](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417201946361.png)



![image-20200417203443617](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417203443617.png)





### 一.运算部署,性能压测

#### 项目云端部署

将本地项目打包成可执行程序

在pom.xml中添加

```xml
<plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
```

在项目根目录下,使用命令

```bash
mvn clean package
```

接下来将ar包上传到服务器,使用jar命令直接启动即可

```java
java -jar miaosha.jar 
```

使用外挂配置文件的方式启动

```bash
java -jar miaosha.jar --spring.config.additional-location=配置文件路径
```

**部署脚本**

```bash
nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar
```

#### jmeter性能压测

工具简介

* 线程组

* http请求

* 查看结果树

* 聚合报告

##### 使用  

1. 新建线程组  

   ![image-20200417222109598](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417222109598.png)

2. 新建http请求

   ![image-20200417222736169](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417222736169.png)

3. 添加结果树

4. 添加聚合报告

   ![image-20200417223021806](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417223021806.png)



#### 如何发现系统瓶颈问题

* 容量问题-server端并发线程数上不去

* 响应时间变长,TPS()系统吞吐量上不去

  > top -H
  >
  > 查看机器的性能
  >
  > ![image-20200417223752661](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417223752661.png)
  >
  > ps -ef | grep java
  >
  > 查看服务启动的端口
  >
  > pstree -p port | wc -l
  >
  > 查看Tomcat线程池中线程的数量

  并发上不去: Tomcat维护的线程池的最大数量不够服务突然到来的请求,当请求太多时,spring内嵌的Tomcat就会拒绝请求,这时使用jemeter就会在聚合报告中看到error

  压测结果:

  ![image-20200417225343556](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417225343556.png)

  CPU多数是耗在mysql和java程序上

  **TPS: 230就上不去了**

  **解决---提高并发**

  ![image-20200417224611801](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417224611801.png)

  ![image-20200417224635094](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417224635094.png)

将Tomcat的默认配置进行修改(在外挂配置文件中):

![image-20200417224927804](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417224927804.png)

**解决2---内嵌Tomcat开发**

内嵌Tomcat的一些配置并没有直接暴露出来给用户配置

建立长连接,避免频繁建立连接浪费时间

![image-20200417225853676](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200417225853676.png)

使用代码的形式对内嵌Tomcat隐藏的参数进行配置

```java
//当Spring容器内没有TomactEmbeddedServlertContainerFactory这个bean时,会将此bean加载进spring容器
@Component
public class WebServerConfiguration implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
    @Override
    public void customize(ConfigurableWebServerFactory factory) {
        //使用对应工厂类提供给我们的接口定制化我们的Tomcat connector
        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(new TomcatConnectorCustomizer() {
            @Override
            public void customize(Connector connector) {
                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();
                //30秒内没有请求则服务器自动断开keeplive连接
                protocol.setKeepAliveTimeout(30000);
                //当客户端发送超过10000个请求则自动断开keepalive连接
                protocol.setMaxKeepAliveRequests(10000);
            }
        });
    }
}
```

**解决--容量问题**

拐点:800(4核8G内存)

当请求超过了800,请求就会进入队列缓冲池(太多会占用内存)

![image-20200418092617757](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418092617757.png)

mysql容量问题

**尽量使用主键索引或者唯一索引**

非唯一索引查询就会全表扫描(分库分表)

![image-20200418092910739](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418092910739.png)

![image-20200418093031529](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418093031529.png)





### 二.**解决单机容量限制**

1. 使用Nginx反向代理负载均衡
2. 分布式会话管理
3. 使用redis实现分布式会话存储

#### 1.使用Nginx反向代理负载均衡

基于Nginx对单机容量进行水平扩展

> (使用同一个域名代理到不同的application server上,Nginx可以代理后端的Tomcat服务器集群,以一个统一的域名的方式暴露出去,供用户调用
>
> 对Nginx上的负载均衡的配置,使用**轮询**等等方式



目前项目的部署结构:(一台服务器)

<img src="C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418094058767.png" alt="image-20200418094058767" style="zoom:50%;" />



<img src="C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418094134248.png" alt="image-20200418094134248" style="zoom:50%;" />服务器干不仅要运行程序还要查询数据库



**改进部署架构**

* mysql数据库开放远端连接
* 服务端水平部署
* 验证访问

改进之后的部署结构:(4台服务器,一台Nginx,一台mysql,两台miasha.jar)

<img src="C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418100523293.png" alt="image-20200418100523293" style="zoom:67%;" />



**mysql开放远端连接**

数据库默认是只允许本机程序访问,需要重新设置一下:

![image-20200418095440311](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418095440311.png)

使用命令 `flush privileges`使得设置生效



#### 2.Nginx

* 使用Nginx作为web服务器

  HTML页面资源

* 使用Nginx作为动静分离服务器

* 使用Nginx作为反向代理服务器

  反向代理到后端

1. 修改前端资源用于部署Nginx

   修改前端页面Ajax请求的地址,使之能够访问云服务器

2. 部署Nginx

   这里使用的是**openResty**,下载OpenResty框架的源码,然后编译即可

3. 指定Nginx web服务器

![image-20200418101803210](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418101803210.png)

4. 部署前端资源在Nginx服务器上

   把HTML以及一些css和js一起上传到Nginx/html目录,直接访问

5. 前端资源路由

![image-20200418103025310](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418103025310.png)

修改之后的访问:

![image-20200418103422780](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418103422780.png)

6. Nginx 动静分离服务器部署

   ![image-20200418103546354](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418103546354.png)



![image-20200418103623722](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418103623722.png)

> upstream是真正的后端服务器反向代理的节点

![image-20200418103828273](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418103828273.png)

![image-20200418104040129](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418104040129.png)

7. 开启Tomcat Access log

   有请求到来时,Tomcat会记录

   ![image-20200418104631188](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418104631188.png)

8. 将应用服务器和后端Nginx服务器的连接配置为长连接,减少建立连接和断开连接的耗时

   ![image-20200418115652326](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418115652326.png)

![image-20200418115733117](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418115733117.png)

**Nginx的高性能原因**

* epoll多路复用

  采用的是非阻塞式IO操作,解决了io阻塞回调通知的问题

  > bio,select,epoll
  >
  > * bio
  >
  >   阻塞式进程模型
  >
  >   ![image-20200418134441873](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418134441873.png)
  >
  > * select 模型
  >
  >   server阻塞自己,并监听client和server的连接,一旦连接发生变化就唤醒自己,遍历这100个连接,找到发生变化的那个,执行read操作
  >
  >   ![image-20200418134739230](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418134739230.png)
  >
  >   一个select复用多个连接
  >
  >   缺点:轮询查找,效率很低,至多只能监听1024个
  >
  > * epoll模型
  >
  >   ![image-20200418135014280](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418135014280.png)
  >
  >   不需要轮询,每个连接上都注册了一个回调函数,当这个链接发生变化,立即执行注册在其上的回调函数,而且epoll理论上监听无上限(netty框架就是基于epoll模型的)

* master worker进程模型

  可以做平滑重启

  ![image-20200418135333580](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418135333580.png)

  ![image-20200418135359592](C:\Users\张恒\AppData\Roaming\Typora\typora-user-images\image-20200418135359592.png)

  master用来管理worker进程,当client来请求时,master让worker们去抢这个链接,抢到之后便开始握手通信.master只处理管理员的信号,比如reload配置,new一个新的worker.master进程可以拿到每个worker进程内的socket句柄,reload配置的时候会先将socket句柄收回,然后创建一个新的worker进程,然后将socket句柄交给新的worker进程

* 协程机制

  依附于线程的内存模型,切换开销小

  遇到阻塞归还执行权,代码同步

  无需加锁

  

### 三.会话管理

![image-20200418140824611](C:\Users\张恒\AppData\Roaming\Typora\typora-user-images\image-20200418140824611.png)

>  因为使用了两台应用服务器,而两台服务器的session是不共享的,没有集中维护,因此要使用分布式会话

分布式会话管理(迁移到redis中):

![image-20200418141347426](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418141347426.png)

> redis是分布式会话的不二之选

1. 分布式会话实现----基于cookie传输sessionId

   安装reids,在application.properties中配置springBoot对redis的依赖配置

   ![image-20200418143119685](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418143119685.png)

   ![image-20200418142524689](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418142524689.png)

   只需要这样配置,这样应用在启动时就会自动连接到redis服务器

> redis使用的序列化方式就是jdk的序列化方式,因此存入redis的对象对应的类要实现serializable接口.在秒杀项目中用户登录后会将用户的userModel存入session中,而此时的session是存在于redis中的,因此要对UserModel类实现序列化接口或者也可以修改redis的默认序列化方式为json方式

2. 分布式会话实现--基于token传输sessionid

   用java代码将token存储到redis中

> 发生连接请求时,若登录验证成功,服务器将对应的登录信息和登录凭证一起存放到redis中

* 生成登录凭证--UUID

  ![image-20200418144802152](C:\Users\张恒\AppData\Roaming\Typora\typora-user-images\image-20200418144802152.png)



### 四.查询优化--多级缓存

1. 多级缓存的定义

   * 内存,快速
   * 将缓存推到离用户最近的地方
   * 脏缓存清理

2. redis缓存,本地缓存

   * redis缓存

     * 单机版
     * 哨兵模式
     * 集群模式

     * 缓存在应用服务器内

   特殊格式在redis中的序列化 与反序列化:

   1. 存入redis中的对象对应的类必须实现序列化接口
   2. jodaTime日期格式必须要做扩展,序列化与反序列化,这样存入redis才不会乱码

   > 压测结果,TPS直接上升到2000并且缩短了响应时间

   * 热点内存本地缓存

     * 热点数据
     * 脏读不敏感
     * 内存可控

     Guava cache组件:

     <img src="C:\Users\张恒\AppData\Roaming\Typora\typora-user-images\image-20200418155330956.png" alt="image-20200418155330956" style="zoom:50%;" />

     ![image-20200418160018748](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418160018748.png)

     重新编写存储逻辑(暂时):

     本地缓存(应用服务器内)-->redis缓存-->数据库

     失效时间:

     数据库(永久) > redis > 本地缓存

     > 压测结果: TPS-->3000

   * Nginx 缓存

     1. Nginx proxy cache缓存

        依靠文件系统存索引级的文件

        依靠内存缓存文件地址

        ![image-20200418161209730](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418161209730.png)

        > 文件还是在Nginx的磁盘上而不是Nginx的内存中,因此压测结果TPS反而降低了

        **因此这种方式是被抛弃的**

     2. Nginx lua 缓存

        Nginx携程:

        每一个worker进程都是在epoll或kqueue这种事假模型之上封装成协程

3. 热点Nginx lua缓存

   ![image-20200418190605895](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418190605895.png)



![image-20200418191027257](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418191027257.png)

> openResty由Nginx核心加上很多第三方模块组成,默认继承了Lua开发环境,是的Nginx可以作为一个web server使用
>
> ![image-20200418191747315](C:\Users\张恒\AppData\Roaming\Typora\typora-user-images\image-20200418191747315.png)

Nginx使用location拦截http请求并将对应的请求进行转发.如果使用lua也是一样

![image-20200418193226278](C:\Users\张恒\AppData\Roaming\Typora\typora-user-images\image-20200418193226278.png)

拦截请求然后执行lua脚本



![image-20200418194055952](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418194055952.png)





#### 静态资源cdn的引入

cdn,内容分发网络.静态资源放到cdn服务器上,如果没有就会回源到Nginx

![image-20200418195226934](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418195226934.png)

### 交易性能瓶颈(四百多TPS)

![image-20200418221200665](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418221200665.png)

* 交易验证完全依赖于数据库

  > 校验下单商品是否存在
  >
  > 校验用户是否合法
  >
  > 校验活动是否正在进行中
  >
  > 订单入库

  **将用户对象和下单商品做到redis缓存中去**

* 库存行锁

  > 落单减库存操作(行锁等待),

  活动发布,同步库存到缓存中

  下单减缓存库存

  异步消息扣减数据库内库存

  > 异步消息队列中间件-rocketmq
  >
  > 高性能,高并发,分布式消息中间件
  >
  > 应用场景:分布式事务,异步解耦

**rocketmq**

![image-20200418224901478](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418224901478.png)

一个topic可以被一个broker管理也可以被多个broker管理

工作流程:

broker先启动,向NameServer发出一个注册请求(告知对方自己的ip以及自己管理哪些topic以及queue).producer会连接上Nameserver,发现 注册其上的broker,当producer想要投递信息时就轮询某个broker中的queue,将信息投递进去.consumer启动连接上NameServer,告知NameServer自己要 抓取那个topic的信息,NameServer就会告知其到那个broker去取消息,取完就删除响应的消息(长轮询,没有拉取到信息就等待,有消息了consumer就会被唤醒)

> 好的消息中间件应该做到queue的数量和consumer的数量相当

![image-20200418230358848](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418230358848.png)

![image-20200418230639247](C:\Users\张恒\Desktop\Javaweb\L\秒杀系统\image-20200418230639247.png)

软状态: 存在状态的不一致,但是最终数据库和redis保持一致就可

* 后置处理逻辑



优化

1. 校验验证优化

   用户风控策略优化: 策略缓存模型化.

   活动校验策略优化:引入活动发布流程,模型缓存化,紧急下线能力



> 流程:
>
> 现在redis内做减库存操作,做完之后发送给库存的异步回调,然后在异步回调内对数据库减库存

问题: 少卖

分布式事务的问题,减库存在redis中,和数据库中的减库存操作是异步的,不在一个事务内,如果数据库那边落单失败,redis这边不可能回滚,造成货物的积压

解决: RocketMq,事务型消息,让消息的投递和数据库的事务相关联

**事务型消息**

