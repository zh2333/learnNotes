> JAVA面试高频点

* JVM
* 多线程与高并发
* java集合类

![image-20201219111135414](E:\learningNotes\面试专题\pic\image-20201219111135414.png)



### 一.请谈谈你对volatile的理解

1. volatile是java虚拟机提供的轻量级的同步机制

   * 保证可见性

     一个线程将共享变量修改完并写回到主内存, 其他的线程能立刻感知到

     ```java
     package com.interview.study.thread;
     import java.util.concurrent.TimeUnit
     class MyData {
         volatile int  number = 0;
         public void addT060() {
             this.number = 60;
         }
     }
     
     /**
      * 验证volatile的可见性
      * 1.没加volatile修饰number, 主线程永远不会打印, 因为其感知不到number被修改了
      * 2.使用volati,e修饰number, 主线程会打印, 因为其能感知到number被修改了
      */
     public class VolatileDemo {
         public static void main(String[] args) {
             MyData myData = new MyData();
             new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t come in");
                //暂停一会线程
                 try {
                     TimeUnit.SECONDS.sleep(3);
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
                 myData.addT060();
                 System.out.println(Thread.currentThread().getName() + "\t update number value:" + myData.number);
             }, "AAA").start();
     
             //主线程
             while (myData.number == 0) {
                 //只要number的值为0, 主线程就一直等待
             }
             System.out.println(Thread.currentThread().getName() + "\t misson over, get value:"+myData.number);//只要打印出这句话, 说明主线程已经感知到了number被修改
         }
     }
     ```

   * 不保证原子性

     ```java
     public static void automic() {
             MyData myData = new MyData();
     
             for (int i = 0; i < 20; i++) {
                 new Thread(() -> {
                     for (int j = 0; j <= 1000; j++) {
                         myData.addPlusPlus();
                     }
                 }, String.valueOf(i)).start();
             }
     
             /**
              * 等待全部计算线程计算完毕
              */
             while (Thread.activeCount() > 2) {
                 Thread.yield();
             }
     
             System.out.println(Thread.currentThread().getName() + "\t finally number value: " +  myData.number);
         }
     //main	 finally number value: 19844
     ```

     > number++在多线程环境是非线程安全的, 如何在不加synchonized的情况下保证原子性?
     >
     > ![image-20201219144133288](E:\learningNotes\面试专题\pic\image-20201219144133288.png)
     >
     > 加一操作在JVM中是三个操作
     >
     > 解决: syncchronized太重了, 使用automicInteger就可以保证加法的原子性

   * 禁止指令重排

     > 指令重排:
     >
     > 1. 单线程环境确保了程序最终执行结果和代码顺序执行的结果一致
     >
     > 2. 计算机在执行程序时, 为了提高性能, 编译器和处理器常常会对指令做重排, 一般分为一下三种:
     >
     > ​    **源代码 -> 编译器优化的指令重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令流**
     >
     > 3. 处理器在进行重排时需要考虑指令之间的**数据依赖性**.多线程环境中线程**交替执行**, 由于编译器优化重排的存在, 两个线程中使用的变量能否保证一致性是无法确定的, 结果无法预测
     >
     > 4. 禁止指令重排的原理:
     >
     >    在指令前插入一条Memory Barrier则会告诉编译器和CPU, 不管什么指令都不能喝这条Memory Barrier指令重排序, 也就是说通过插入内存屏障禁止在内存内存屏障前后的指令执行重排序优化. 内存屏障的另外一个作用是强制刷出各种CPU的缓存数据, 因此任何CPU上的线程都能读取到这些数据的最新版本

   > volatile实现了JMM内存模型规范中的两点, 可见性和有序性, 不保证原子性, syncronized保证原子性

2. 谈谈JMM(java内存模型)

   * 可见性
   * 原子性
   * 有序性

   jmm本身是一种抽象的概念, 并不真实存在, 他描述的是一种规则, 通过这种规则定义了程序中各个变量的访问方式

   `jmm关于同步的规定:`

   * 线程解锁前, 必须把共享变量的值刷新会主内存
   * 线程加速前, 必须读取主内存的最新值到自己的工作内存
   * 加锁和解锁是同一把锁

   > 由于jvm运行程序的实体是线程, 而每个线程创建时都会为其创建一个工作内存(栈空间), 工作内存是每个线程的私有数据区域, 而java内存模型中规定所有变量都存储在主内存中, 主内存是共享内存空间, 所有的线程都可以访问, 但是线程对变量的操作必须在工作内存中进行, 首先要将变量从主内存中拷贝到自己的工作内存, 然后读变量进行操作, 操作完成后在将变量写回主内存, 不能直接操作主内存中的变量, 各个线程中的工作内存中存储着主内存中的变量副本拷贝, 因此不同的线程间无法访问对方的工作内存, 线程间的通信必须通过主内存来完成
   >
   > ![image-20201219113437783](E:\learningNotes\面试专题\pic\image-20201219113437783.png)

3. 你在哪些地方用过volatile?

   * 单例模式DCL代码

     ```java 
     public class SingletonDemo {
         private static SingletonDemo instance = null;
     
         private  SingletonDemo() {
             System.out.println(Thread.currentThread().getName() + "\t 实例化");
         }
     
         private static SingletonDemo getInstance() {
             if (instance == null) {
                 instance = new SingletonDemo();
             }
             return instance;
         }
     
         public static void main(String[] args) {
     //        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
     //        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
     //        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
     
             for (int i = 1; i <= 10; i++) {
                 new Thread(()-> {
                     SingletonDemo.getInstance();
                 }, String.valueOf(i)).start();
             }
     
         }
     }
     //2	 实例化
     //4	 实例化
     //1	 实例化
     //3	 实例化
     //这种情况并不能保证单例
     ```

     > 使用synchronized修饰getInstance方法当然是可以保证单例的, 但是太重了. 我们其实需要锁的就只有`instance = new SingletonDemo();`这一行代码而已.因此加锁是需要的, 但是需要减小锁的粒度

     ```java
     private static SingletonDemo getInstance() {
             if (instance == null) {
                 synchronized (SingletonDemo.class) {
                     if (instance == null) {
                         instance = new SingletonDemo();
                     }
                 }
             }
             return instance;
         }
     ```

   * 单例模式volatile分析

     DCL机制不一定安全, 原因是指令重排的存在, 加入volatile可以禁止指令重排

     原因在于某一个线程执行到第一次检测, 读取到的instance不为null时, instance的引用对象可能没有完成初始化工作.

     instance = new SingletonDemo() 可以分为以下三步完成:

     * 为对象分配内存空间
     * 初始化对象
     * 设置instance指向刚分配的内存空间, 此时instance != null

     jvm为了指令执行效率, 会将第二步和第三步重排, 其他线程会拿到不为空, 但是实际上没有初始化完成的对象, 在执行其他操作时会有问题.需要给instance加上volatile

   ### CAS你知道吗?

   1. 比较并交换  **compare and swap**

      如果线程的期望值和主内存的值一样, 就将自己的修改值写会主内存.如果不一样, 写回失败

   2. CAS底层原理.如果知道, 请谈谈你对Unsafe的理解

      > 底层原理: 1.自旋锁 2.Unsafe类
      >
      > 工作原理: 比较当前工作内存中的额值和主内存中的值, 如果相同则执行规定操作, 否则继续比较知道主内存和工作内存中的值一致为止. 

      * automicInteger.getAndIncrement()

        ![image-20201219170934888](E:\learningNotes\面试专题\pic\image-20201219170934888.png)

        调用的是Unsafe中的方法

        ![image-20201219171138083](E:\learningNotes\面试专题\pic\image-20201219171138083.png)

      * Unsafe

        Unsafe是CAS的核心类, 由于java方法无法直接访问底层系统, 徐亚通过本地方法, native方法来访问, Unsafe相当于一个后门, 基于该类可以直接操作特定内存的数据.Unsafe类存在于sum.misc包中, 其内部方法操作可以像C语言的指针一样直接操作内存, 因为java中CAS操作的执行依赖于Unsafe类的方法.

        > Unsafe类中所有方法收拾native修饰的, 也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应的任务.valueOffset指的就是数据在内存中的地址, 且数据变量使用的是volatile关键字修饰的

      * CAS是什么(自旋)

        CAS全称为compare-and-swamp, 他是一条CPU并发原语.他的功能时判断内存中某个位置的值是否为预期值, 如果是则更改为新的值, 这个过程是原子的.

        CAS并发原语体现在java语言中就是sun.misc.Unsafe类中的各个方法. 调用Unsafe类中的CAS方法, JVM会帮我们实现CAS汇编指令. 这是一种完全依赖于硬件的功能, 通过他实现了原子操作. 由于CAS是一种系统原语, 原语属于操作系统用范畴, 是由若干条指令组成的, 用于完成某个功能的一个过程, 并且原语的执行必须是连续的, 在执行过程中不允许被终端, 也就是说CAS是CPU的一条原子指令, 不会造成数据不一致的问题.

        ![image-20201219172645329](E:\learningNotes\面试专题\pic\image-20201219172645329.png)

        在这里自旋了.比较失败后, 再获得该内存地址变量的最新值再比较, 此时若获取的是其他线程修改后的新值, 加法操作就会成功.否则再获得最新值作为自己的期望值, 再比较, 直至成功.

        > var1 AtomicInteger对象本身
        >
        > var2 该对象值的引用地址
        >
        > var4 需要变动的数量
        >
        > var5 该变量当前在内存中的真实值
        >
        > 用该对象的当前值和主内存中的该对象的值进行比较, 如果相同, 更新var5+var4并且返回true,
        >
        > 如果不同, 继续取值, 然后再比较, 直到更新完成

        为啥使用CAS而不是syncronized?

        后者虽然可以保证一直性, 但是并发度下降.使用CAS可以提高并发性.

        <img src="E:\learningNotes\面试专题\pic\image-20201219190454762.png" alt="image-20201219190454762" style="zoom: 67%;" />

        > compareAndSwampInt, 是一个本地方法, 该方法的实现位于Unsafe.cpp

        ![image-20201219190700222](E:\learningNotes\面试专题\pic\image-20201219190700222.png)

   3. CAS 缺点

      * 长时间自旋, CPU开销大
      * 只能保证一个共享变量的原子操作, 对于多个共享变量的操作只能通过syncronized来保证
      * ABA问题

### 二.原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗?

* 原子引用

  CAS算法实现的一个重要前提是需要取出内存中某时刻的数据并在当下时刻比较并替换, name在这个时间差内会导致数据的变化. 比如一个线程one从内存位置V取出A, 这个时候另一个线程two也从主内存重取出A, 并且线程two进行了一些操作将值变成B, 然后线程two又将V位置的数据变成A, 这时候线程one进行CAS操作发现内存中任然是A, 然后线程one操作成功.**尽管线程one的CAS操作成功, 但是不代表这个过程是没问题的**

* 原子引用

  ```java
  package com.interview.study.thread;
  
  
  import java.util.concurrent.atomic.AtomicReference;
  
  class User {
      String userName;
      int age;
  
      public User(String userName, int age) {
          this.userName = userName;
          this.age = age;
      }
  
      public String getUserName() {
          return userName;
      }
  
      public void setUserName(String userName) {
          this.userName = userName;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "User{" +
                  "userName='" + userName + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  public class AtomicReferenceDemo {
      public static void main(String[] args) {
          User z3 = new User("z2", 23);
          User li4 = new User("li4", 24);
          AtomicReference<User> atomicReference = new AtomicReference<>();
          atomicReference.set(z3);
          System.out.println(atomicReference.compareAndSet(z3, li4) + "\t " + atomicReference.get().toString());
      }
  }
  //true	 User{userName='li4', age=24}
  ```

  * 时间戳原子引用

### 三.我们知道ArrayList是线程不安全的, 请编写一个不安全的案例, 并给出解决方案

```java
/**
 * 集合类不安全的问题
 */
public class ContainerNotSafeDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
//	java.util.ConcurrentModificationException
```

vector加了synchronized, 不会报错, 但是性能不好

1. 导致原因

   多个线程并发修改

2. 解决方案

   * new vector<>() :x:

   * Collections.synchronizedList(new ArrayList<>());  :x:

   * new CopyOnWriteArrayList<>() :heavy_check_mark:

     写时复制, 读写分离的思想

     ```java
     public boolean add(E e) {
             final ReentrantLock lock = this.lock;
             lock.lock();
             try {
                 Object[] elements = getArray();
                 int len = elements.length;
                 Object[] newElements = Arrays.copyOf(elements, len + 1);
                 newElements[len] = e;
                 setArray(newElements);
                 return true;
             } finally {
                 lock.unlock();
             }
         }
     ```

     > CopyOnWrite容器即写时复制的容器. 向一个容器中添加元素时, 不直接向当前同期Object[]中添加, 而是先将当前容器Object[]进行copy, 复制出一个新的额容器Object[] , 然后向新的容器中添加元素, 添加完后将原容器的引用指向新的容器.这样做的好处是可以对CopyOnWrite容器进行并发的读, 而不需要加锁, 因为当前容器不会添加任何新的元素, 所以是一种读写分离的思想, 读和写不同的容器(**适合写少读多的场景**)

3. 集合类不安全之set

   ```java
   public class ContainerNotSafeDemo {
       public static void main(String[] args) {
           Set<String> set  = new HashSet<>();
   
           Collections.synchronizedList(new ArrayList<>());
           for (int i = 0; i < 30; i++) {
               new Thread(()->{
                   set.add(UUID.randomUUID().toString().substring(0, 8));
                   System.out.println(set);
               }, String.valueOf(i)).start();
           }
       }
   }
   // java.util.ConcurrentModificationException
   ```

   new CopyOnWriteArraySet<>()底层使用的也是CopyOnWriteArrayList

   HashSet底层是用HashMap实现的, 之所以只用添加一个值(map中的key), 是因为value是一个对象常量

4. 集合类不安全之map

   使用concurrentHashMap :question:

### 四.公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解? 请手写一个自旋锁

1. 公平锁/非公平锁

   * 公平锁 是指多个线程按照申请锁的顺序来获取锁, 先来后到   new ReetrantLock(true)

   * 非公平锁 是指多个线程获取锁的顺序并不会按照申请锁的顺序, 有可能后申请的线程比先申请的线程优先获取锁. 在高并发场景下可能会造成优先级反转或者饥饿现象  new ReetrantLock(false).其优点在于吞吐量大.**对于syncchronized而言, 其也是一种非公平锁**

     > 非公平锁上来直接尝试占用锁, 如果尝试失败, 再采用类似公平锁的那种方式

2. 可重入锁(递归锁)

   * 是什么

     指的是同一线程外层函数获得锁之后, 内层递归函数仍然能获取该锁的代码

     在同一个线程在外层方法获取锁的时候, 在进入内层方法会自动获取锁  

     也就是说, 线程可以进入任何一个它已经拥有的锁所同步着的代码块

   * ReentrantLock/Syncchronized 就是一个典型的可重入锁

   * 可重入锁的最大的作用是避免死锁

   * demo

     syncchronized是一种可重入锁

     ```java
     class Phone {
         public synchronized static void sendSms() throws Exception {
             System.out.println(Thread.currentThread().getName() + "\t invokr sendSms");
             sendMail();
         }
     
         public synchronized static void sendMail() throws Exception {
             System.out.println(Thread.currentThread().getName() + "\t invoke sendMail");
         }
     }
     public class ReentrantLockDemo {
         public static void main(String[] args) {
             Phone phone = new Phone();
     
             new Thread(()->{
                 try {
                     phone.sendSms();
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }, "t1").start();
     
             new Thread(()->{
                 try {
                     phone.sendMail();
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }, "t2").start();
         }
     }
     //------------------------
     t1	 invokr sendSms
     t1	 invoke sendMail
     t2	 invoke sendMail
     //两个线程并发执行, t1在获得sms方法的锁之后自动获取了mail方法的锁. 所以t2线程如果一开始就没有抢mail的锁, 因为两个锁是一把锁, t2只能等待t1将两个方法全部执行完成后才能抢占mail方法的锁, 然后执行mail 方法
     ```

     ReentrantLock

     ```java 
     class Phone2 implements Runnable {
     
         Lock lock = new ReentrantLock();
         @Override
         public void run() {
             get();
         }
     
         public void get() {
             lock.lock();
             try {
                 System.out.println(Thread.currentThread().getName() + "\t invoke get");
                 set();
             } finally {
                 lock.unlock();
             }
         }
     
         public void set() {
             lock.lock();
             try {
                 System.out.println(Thread.currentThread().getName() + "\t invoke set");
             } finally {
                 lock.unlock();
             }
         }
     }
     
     public class ReentrantLockDemo {
         public static void main(String[] args) {
             Phone2 phone2 = new Phone2();
     
             Thread t3 = new Thread(phone2, "t3");
             Thread t4 = new Thread(phone2, "t4");
             t3.start();
             t4.start();
         }
     }
     //-----------------------
     t3	 invoke get
     t3	 invoke set
     t4	 invoke get
     t4	 invoke set
     ```

     > 加几把锁无所谓, 但是加锁和释放锁要匹配

3. 自旋锁

   指的是尝试获取锁定额线程在没有获取到锁的情况下, 不会立即阻塞(:exclamation:), 而是采取循环的方式尝试获取锁, 这样的好处:

   **减少线程上下文切换的消耗,** 

   缺点:

   **会消耗CPU**

   ![image-20201220140105052](E:\learningNotes\面试专题\pic\image-20201220140105052.png)
   
4. 手动实现自旋锁

   ```java
   public class SpinLockDemo {
   
       AtomicReference<Thread> atomicReference = new AtomicReference<>();
   
       public void myLock() {
           Thread thread = Thread.currentThread();
           System.out.println(Thread.currentThread().getName() + "\t invoke lock");
           while(!atomicReference.compareAndSet(null, thread)) {
               System.out.println(Thread.currentThread().getName() + "\t 获取失败, 自旋");
           }
           System.out.println(Thread.currentThread().getName() + "\t 获取成功");
       }
   
       public void muUnlock() {
           Thread thread = Thread.currentThread();
           atomicReference.compareAndSet(thread, null);
           System.out.println(Thread.currentThread().getName() + "\t invoke unlock");
       }
   
       public static void main(String[] args) {
           SpinLockDemo spinLockDemo = new SpinLockDemo();
           new Thread(()->{
               spinLockDemo.myLock();
               try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
               spinLockDemo.muUnlock();
           }, "AA").start();
   
   
           try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
   
           new Thread(()->{
               spinLockDemo.myLock();
               spinLockDemo.muUnlock();
           }, "BB").start();
       }
   }
   //--------------------
   AA	 invoke lock
   AA	 获取成功
   BB	 invoke lock
   AA	 invoke unlock
   BB	 获取成功
   BB	 invoke unlock
   ```

5. 独占锁(:exclamation:写锁)/共享锁(:exclamation:读锁)/互斥锁

   * 独占锁

     指的是该锁一次只能被一个线程所持有. 对ReentrantLock和synchronized而言都是独占锁

   * 共享锁

     指该所可以被多个线程锁持有

     对**ReenTrantReadWriteLock**其读锁是共享锁, 其写锁是独占锁

     读锁的共享锁可保证并发读是非常高效的, 读写, 写读, 写写的过程是互斥的

     > 多个线程同时读一个资源类没有问题, 所以为了满足并发量, 读取共享资源应该可以同时进行.
     >
     > 但是:
     >
     > 如果一个线程想去写共享资源来, 就不应该再有其他线程可以对该资源进行读或者写
     >
     > 小总结:
     >
     > ​	读-读不能共存
     >
     > ​	读-写不能共存
     >
     > ​	写-写不能共存

     资源类未加读写锁

     ```java
     class MyCache1 {//资源类
         private volatile Map<String, Object> map = new HashMap<>();//多线程写必须使用volatile修饰共享变量
         public void put(String key, Object value) {
             System.out.println(Thread.currentThread().getName() + "\t 正在写入" + key);
             try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
             map.put(key, value);
             System.out.println(Thread.currentThread().getName() + "\t 写入完成");
         }
     
         public void get(String key) {
             System.out.println(Thread.currentThread().getName() + "\t 正在读取" + key);
             try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
             map.get(key);
             System.out.println(Thread.currentThread().getName() + "\t 读取完成");
         }
     }
     
     public  static void notsafe() {
             MyCache1 myCache = new MyCache1();
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.put(tmpInt+"", tmpInt);
                 }, String.valueOf(i)).start();
             }
     
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.get(tmpInt+"");
                 }, String.valueOf(i)).start();
             }
         }
     //-----------------------------
     1	 正在写入1
     2	 正在写入2
     3	 正在写入3
     5	 正在写入5
     4	 正在写入4
     3	 正在读取3
     5	 正在读取5
     4	 正在读取4
     1	 正在读取1
     2	 正在读取2
     3	 写入完成
     2	 读取完成
     1	 写入完成
     3	 读取完成
     4	 读取完成
     5	 读取完成
     1	 读取完成
     5	 写入完成
     4	 写入完成
     2	 写入完成
     ```

     资源类加上读写锁

     ```java
     class MyCache2 {//资源类
         private volatile Map<String, Object> map = new HashMap<>();//多线程写必须使用volatile修饰共享变量
         private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
         public void put(String key, Object value) {
     
             readWriteLock.writeLock().lock();//写锁加锁, 再次期间不能读写
             try {
                 System.out.println(Thread.currentThread().getName() + "\t 正在写入" + key);
                 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
                 map.put(key, value);
                 System.out.println(Thread.currentThread().getName() + "\t 写入完成");
             } finally {
                 readWriteLock.writeLock().unlock();//写锁释放
             }
     
         }
     
         public void get(String key) {
             readWriteLock.readLock().lock();//写锁加锁, 再次期间可读不可写
             try {
                 System.out.println(Thread.currentThread().getName() + "\t 正在读取" + key);
                 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
                 map.get(key);
                 System.out.println(Thread.currentThread().getName() + "\t 读取完成");
             } finally {
                 readWriteLock.readLock().unlock();//写锁释放
             }
         }
     }
     public  static void safe() {
             MyCache2 myCache = new MyCache2();
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.put(tmpInt+"", tmpInt);
                 }, String.valueOf(i)).start();
             }
     
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.get(tmpInt+"");
                 }, String.valueOf(i)).start();
             }
         }
     //----------------------
     1	 正在写入1
     1	 写入完成
     4	 正在写入4
     4	 写入完成
     2	 正在写入2
     2	 写入完成
     3	 正在写入3
     3	 写入完成
     5	 正在写入5
     5	 写入完成
     3	 正在读取3
     1	 正在读取1
     4	 正在读取4
     2	 正在读取2
     5	 正在读取5
     4	 读取完成
     2	 读取完成
     5	 读取完成
     3	 读取完成
     1	 读取完成
     ```

### 五.CountDownLatch/CycliBarrier/Semaphore使用过吗?

1. CountDownLatch

* 定义

  让一些线程阻塞知道另一些线程完成一系列操作后才被唤醒

* 工作原理

  countDownLatch主要由两个方法, 当一个或者多个线程调用await方法时, 调用线程会被阻塞.其他线程调用countDo恩方法时会将计数器减一(调用countDown方法的线程不会阻塞), 当计数器值减为零时,, 因调用await方法被阻塞的线程会被唤醒继续执行

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for (int i = 1; i <= 5 ;i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t 上完自习, 离开教室");
                countDownLatch.countDown();
            }, String.valueOf(i)).start();
        }
        countDownLatch.await();//在这个位置等待所有的线程执行完成, 主线程才继续向下走
        System.out.println(Thread.currentThread().getName() + "\t 班长关门走人");
    }
}
//-------------------------
1	 上完自习, 离开教室
5	 上完自习, 离开教室
4	 上完自习, 离开教室
3	 上完自习, 离开教室
2	 上完自习, 离开教室
main	 班长关门走人
```

在解耦中使用枚举类

```java
public  enum CountyEnum {
    ONE(1, "齐国"), TWO(2, "楚国"),THREE(3, "燕国"),FOUR(4 ,"赵国"),FIVE(5, "韩国");

    private Integer retcode;
    private String retMsg;

    CountyEnum(Integer retcode, String retMsg) {
        this.retcode = retcode;
        this.retMsg = retMsg;
    }

    public Integer getRetcode() {
        return retcode;
    }

    public String getRetMsg() {
        return retMsg;
    }

    public static CountyEnum forEach_CountryEnum(int index) {
        CountyEnum[] myArray = CountyEnum.values();
        for (CountyEnum element: myArray) {
            if (index == element.getRetcode()) {
                return element;
            }
        }
        return null;
    }
}
```

2. CyclicBarrier

   可训话使用的屏障. 他要做的事情是, 让一组线程到达一个屏障时被阻塞, 知道最后一个线程到达屏障时, 屏障才会打开, 所有被屏障拦截的线程才能继续运行, 线程进入屏障通过CyclicBarrier的await方法	

   ```java
   public class CyclicBarrierDemo {
       public static void main(String[] args) {
           CyclicBarrier cyclicBarrier = new CyclicBarrier(7, ()->{ System.out.println("*******召唤神龙");});
   
           for (int i = 1; i <= 7 ;i++) {
               final int tmpInt = i;
               new Thread(()->{
                   System.out.println(Thread.currentThread().getName() + "\t 收集" + tmpInt +" 龙珠");
                   try {
                       cyclicBarrier.await();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   } catch (BrokenBarrierException e) {
                       e.printStackTrace();
                   }
               }, String.valueOf(i)).start();
           }
       }
   ```

3. Semaphore

   信号量主要用于两个目的, 一个是用于**多个共享资源的互斥使用**:exclamation:, 另一个用于**并发线程数的控制**:exclamation:

   ```java
   public class SemaphoreDemo {
       public static void main(String[] args) {
           Semaphore semaphore = new Semaphore(3);//三个车位
   
           for (int i = 1; i <= 6;i++) {//6个车抢3个车位
               new Thread(()->{
                   try {
                       semaphore.acquire();//尝试占用车位
                       System.out.println(Thread.currentThread().getName() + "\t 抢到车位");
                       try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
                       System.out.println(Thread.currentThread().getName() + "\t 停车3秒后离开");
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   } finally {
                       semaphore.release();//释放被占用的资源
                   }
               }, String.valueOf(i)).start();
           }
       }
   ```

   

### 六.阻塞队列知道吗

1. 队列 + 阻塞队列

   <img src="E:\learningNotes\面试专题\pic\image-20201220163433598.png" alt="image-20201220163433598" style="zoom:50%;" />

   > 当阻塞队列是空时, 从队列中获取元素的操作将会被阻塞
   >
   > 当阻塞队列 是满时, 向队列中添加元素的操作将会被阻塞

2. 有什么好处?

   在多线程领域, 所谓阻塞, 在某些情况下, 会挂起线程, 一旦条件满足, 被挂起的线程又会被自动唤醒

   好处:

   我们不需要关系什么时候需要阻塞线程, 什么时候需要唤醒线程, 这一切已经被BlockingQueue封装了

   在concurrent包发布以前, 在多线程环境下, 我们每个程序员都必须自己去控制这些细节, 尤其还要兼顾效率和线程安全, 而这会给我们的程序代码不小的复杂度.

3. BlockingQueue的核心方法

   ![image-20201220164407562](E:\learningNotes\面试专题\pic\image-20201220164407562.png)

   <img src="E:\learningNotes\面试专题\pic\image-20201220165411617.png" alt="image-20201220165411617" style="zoom:50%;" />

   * 抛出异常

     add 队列满抛出异常,remove  队列中没有元素时移除抛出异常, element 检查队列是否为空, 若不为空返回队首元素

   * 特殊值

     offer 向队列中添加元素, 如果添加成功返回true, 否则返回false; peek() 返回队首元素但不将其从队列中移除; poll 从队列中弹出元素, 若队列为空, 返回null

   * 阻塞

     put 向队列中添加元素, 如果队列满了, 就阻塞一直等待, 知道队列中有元素被消费空出位置然后再将元素放入队列; take 从队列中取出元素, 如果队列为空就一直等待, 直到队列中有元素供消费

   * 超时

     offer 向队列中添加元素, 如果队列满了, 就等待固定时间, 如果在此时间内队列仍然是满的, 就退出; poll

     从队列中取元素, 如果队列为空, 就等到固定时间, 如果再次时间内队列中仍然没有元素供消费就退出;

   

4. 种类

   * ArrayBlockingQueue: 由数组结构组成的有界阻塞队列:heavy_check_mark:

   * LinkedBlockingQueue: 由链表结构组成的有界阻塞队列(大小默认为**Integer.MAX_VALUE**):heavy_check_mark:

   * PriorityBlockingQueue: 支持优先级排序的误解阻塞队列

   * DelayQueue: 使用优先级队列实现的延迟无界阻塞队列

   * SynchronousQueue: 不存储元素的阻塞队列, 也就是单个元素的队列:heavy_check_mark:

     不存储元素的阻塞队列. 每个put操作必须要等待一个take操作, 否则不能继续添加元素, 反之亦然

     ```java
     public class SynchronousQueueDemo {
         public static void main(String[] args) {
             BlockingQueue<String> blockingQueue = new SynchronousQueue<>();
     
             new Thread(()->{
                 for (int i = 1; i <=3 ; i++) {
                     System.out.println(Thread.currentThread().getName() + "\t put" + i);
                     try {
                         blockingQueue.put(1 + "");
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                 }
             }, "AAA").start();
     
             new Thread(()->{
                 for (int i = 1; i <=3 ; i++) {
                     try {
                         try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
                         System.out.println(Thread.currentThread().getName() + "\t get" + i);
                         blockingQueue.take();
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                 }
             }, "BBB").start();
         }
     }
     //---------------------
     AAA	 put1
     BBB	 get1
     AAA	 put2
     BBB	 get2
     AAA	 put3
     BBB	 get3
     ```

   * LinkedTransFerQueue: 由链表结构组成的无界阻塞队列

   * LinkedBlocking**Deque**: 由链表组成的:exclamation: **双向**:exclamation: 阻塞队列

   > 打钩的三个是重点, 线程池的底层实现

5. 用在哪里

   * 生产者消费者模式

     * 传统版

       ```java
       class ShareData {
           private int number = 0;
           private Lock lock = new ReentrantLock();
           private Condition condition = lock.newCondition();
       
           public  void increment() {
               lock.lock();
               //1.判断
               try {
                   while (number != 0) {
                       condition.await();
                   }
                   //2.干活
                   number++;
                   System.out.println(Thread.currentThread().getName() + "\t" +number);
                   //3.通知唤醒
                   condition.signalAll();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               } finally {
                   lock.unlock();
               }
           }
       
           public  void decrement() {
               lock.lock();
               //1.判断
               try {
                   while (number == 0) {
                       condition.await();
                   }
                   //2.干活
                   number--;
                   System.out.println(Thread.currentThread().getName() + "\t" +number);
                   //3.通知唤醒
                   condition.signalAll();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               } finally {
                   lock.unlock();
               }
           }
       
       }
       public class ProducerConsumer_TransactionalDemo {
           public static void main(String[] args) {
               ShareData shareData = new ShareData();
       
               new Thread(()->{
                   for (int i = 1; i <=5 ; i++) {
                       shareData.increment();
                   }
               }, "AAA").start();
       
               new Thread(()->{
                   for (int i = 1; i <=5 ; i++) {
                       shareData.decrement();
                   }
               }, "BBB").start();
           }
       }
       //---------------------
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       ```

       

     * 阻塞队列版

       ```java
       class MyResource {
           private volatile boolean FLAG = true;
           private AtomicInteger atomicInteger = new AtomicInteger();
       
           BlockingQueue<String> blockingQueue = null;
       
           public MyResource(BlockingQueue<String> blockingQueue) {
               this.blockingQueue = blockingQueue;
               System.out.println(blockingQueue.getClass().getName());
           }
       
           public void myProd() throws Exception {
               String data = null;
               boolean retCode;
               while(FLAG) {//只要生产线没有停止就一直生产
                   data = atomicInteger.incrementAndGet() + "";
                   retCode = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
                   if (retCode) {
                       System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "成功");
                   } else {
                       System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "失败");
                   }
                   TimeUnit.SECONDS.sleep(1);
               }
               System.out.println(Thread.currentThread().getName() + "\t 生产结束");
           }
       
           public void myConsumer() throws Exception {
               String result = null;
               while (FLAG) {
                   result = blockingQueue.poll(2L, TimeUnit.SECONDS);
                   if (null == result || result.equalsIgnoreCase("")) {//生产者停止生产, 消费者退出
                       FLAG = false;
                       System.out.println(Thread.currentThread().getName() + "\t 消费超时, 消费者结束消费");
                       return;
                   }
                   System.out.println(Thread.currentThread().getName() + "\t 消费队列" + result + "成功");
               }
           }
       
           public void stop() throws Exception {//叫停生产者消费者
               this.FLAG = false;
           }
       }
       
       
       public class ProducerConsumer_BlokingQueueDemo {
           public static void main(String[] args) throws Exception {
       
               MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
               new Thread(()->{
                   try {
                       System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
                       myResource.myProd();
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }, "producer").start();
       
               new Thread(()->{
                   try {
                       System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
                       myResource.myConsumer();
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }, "consumer").start();
       
               try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
       
               System.out.println("生产结束, 生产线停止运行......");
               myResource.stop();
           }
       }
       ```

       

   * 线程池

   * 消息中间件

> 1. 线程   操作   资源类
>
> 2. 判断   干活   唤醒通知
>
> 3. 严防多线程状态下的虚假唤醒

5. synchronized 和lock有什么区别?用新的 lock有什么好处?

   * 原始构成:

     synchronized 是JVM层面, 是java语言的关键字 monitorenter(底层是通过monitor对象来完成, 其中wait/notify等方法也依赖于monitor对象只有在同步块或方法中才能调wait/notify等方法); 

     lock是api层面的锁

   * 使用方法

     synchronized 不需要用户手动释放锁, 当synchronized代码执行完后系统会自动让线程释放对象锁的占用(monitorexit)

     ReentrantLock 则需要用户去手动释放锁, 如果没有主动释放锁, 就有可能会导致死锁

   * 是否可中断

     synchronized不可中断, 除非抛出异常或者正常运行完

     ReentrantLock 可中断, lockInterruptibly()放在代码块中, 调用interrupt方法即可

   * 加锁是否公平

     synchronized是非公平锁

     ReentrantLock两者都可以, 默认是非公平锁, 构造方法可以传入boolean值, true为公平锁, false是非公平锁

   * 锁绑定多个条件Condition

     synchronized没有condition

     ReentrantLock用来实现分组唤醒需要唤醒的线程们, 可以精确唤醒, 而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程

### 线程池用过吗?ThreadPoolExecutor谈谈你的理解?

1. Runnable和Callable接口的区别

   * Runnable无返回值, Callable有返回值

     ```java
     class MyThread2 implements Callable<Integer> {
         @Override
         public Integer call() throws Exception {
             return null;
         }
     }
     ```

     > Thread 类的构造方法中只能传Runnable接口, 如果我们想在构造一个线程的时候传入Callable使其可以返回值怎么做呢? 这个时候就需要一个类同时实现Runnable接口和Callable接口, 在构造一个Thread的时候将new 出来的Thread传入到这个类的构造方法中. 这个同时实现了Runnable接口和Callable的类就是FutureTask接口(适配器模式)

     ```java
     FutureTask<Integer> futureTask = new FutureTask<>(new MyThread2());
     Thread t1 = new Thread(futureTask, "AAA");
     t1.start();
     System.out.println("result: " + futureTask.get());
     ```

     > 为什么要使用callable和futureTask?
     >
     > 异步任务, 当线程运行结束后接受其返回值, 尽量避免阻塞.
     >
     > 由于futureTask.get()会阻塞, 所以尽量将其放在使用返回值的代码处.
     >
     > 也可以使用futureTask.isDone() 判断callable接口是否计算完成, 如果没有计算完成, 就循环, 这样比阻塞的性能会更好点.自旋性能 > 阻塞

     ```java
     FutureTask<Integer> futureTask = new FutureTask<>(new MyThread2());
     
     Thread t1 = new Thread(futureTask, "AAA");
     Thread t2 = new Thread(futureTask, "AAA");
     t1.start();
     t2.start();
     Integer result2 = 1014;
     while (!futureTask.isDone()) {
     
     }
     Integer result1 = futureTask.get();
     System.out.println("result: " + (result1 + result2));
     //----------------------------------
     AAA*************come in callable***************
     result: 2038
     ```

     > 上述代码中, t2不会进入线程, 因为jvm认为和t1的任务相同, 无需做重复的计算
     >
     > 结论:
     >
     > **多个线程抢一个futuretask只会有一个抢到并运行, 另外一个不会运行**

2. 为什么用线程池, 优势有哪些?

   * 什么是线程池

     线程池做的工作主要是控制运行的线程的数量, 处理过程中将任务放在队列中, 然后在线程创建后启动这些任务, 如果线程的最大数量超出了数量的线程排队等候, 再从队列中取出任务来运行

   * 优势(线程复用, 控制最大并发数, 管理线程)

     * 降低资源消耗. 通过重复利用已创建的线程降低线程创建和销毁造成的消耗
     * 提高响应速度. 当任务到达时, 任务可以不需要等到线程创建就能立即执行
     * 提高线程的可管理性. 线城市稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 调优和监控

3. 线程池如何使用

   * 架构说明

     java 中的线程池是通过Executor框架实现的, 该框架中用到了Executor, Executors, ExecutorService, ThreadPoolExecutor这几个类

     <img src="E:\learningNotes\面试专题\pic\image-20201225210513352.png" alt="image-20201225210513352" style="zoom:50%;" />

     <img src="E:\learningNotes\面试专题\pic\image-20201225210604993.png" alt="image-20201225210604993" style="zoom:50%;" />

     > 两个核心重点: 1.**Executors** 2.**ThreadPoolExecutor**
     >
     > Array ====> Arrays
     >
     > Collection ====> Collections
     >
     > Executor ====> Executors
     >
     > 接口  ====>  辅助工具类

     > 到目前为止可以获得线程的方式:
     >
     > 1. new Thread
     >
     > 2. 实现Runnable接口重写run方法
     >
     >    没有返回值, 不抛异常
     >
     > 3. 实现Callable接口重写call方法
     >
     >    有返回值, 会抛异常
     >
     > 4. 使用线程池

   * 编码实现

     * 了解

       * Executors.newScheduledThreadPool()

         带调度的线程池(池子中的任务隔一段时间执行一次)

       * Executors.newWorkStealingPool(int)

         java8新增, 使用目前机器上可用的处理器作为他的并行级别

     * **重点**(下面三个的底层实现都是**ThreadPoolExecutor**)

       * Executors.newFixedThreadPool(int)  ====> 线程池中固定线程数的线程

         ```java
         ExecutorService threadPool = Executors.newFixedThreadPool(5);
                 try {
                     for (int i = 1; i < 10; i++) {
                         threadPool.execute(() -> {
                             System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                         });
                     }
                 }catch (Exception e) {
                     threadPool.shutdown();
                 }
         //-------------------------
         pool-1-thread-1	 办理业务
         pool-1-thread-5	 办理业务
         pool-1-thread-4	 办理业务
         pool-1-thread-3	 办理业务
         pool-1-thread-2	 办理业务
         pool-1-thread-3	 办理业务
         pool-1-thread-4	 办理业务
         pool-1-thread-5	 办理业务
         pool-1-thread-1	 办理业务
         ```

         ![image-20201225213134796](E:\learningNotes\面试专题\pic\image-20201225213134796.png)

         > 1. 创建一个定长线程池, 可控制最大并发数, 超出的线程会在线程中等待
         > 2. newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的

       * Executors.newSingleThreadExecutor()  ====>  

         ```java
         ExecutorService threadPool = Executors.newSingleThreadExecutor();
                 try {
                     for (int i = 1; i < 10; i++) {
                         threadPool.execute(() -> {
                             System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                         });
                     }
                 }catch (Exception e) {
                     e.printStackTrace();
                 } finally {
                     threadPool.shutdown();
                 }
         //-------------------------------
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         ```

         ![image-20201225213311081](E:\learningNotes\面试专题\pic\image-20201225213311081.png)

         > 1. 创建一个单线程化的线程池, 它只会用唯一的工作线程来执行任务, 保证所有的任务按照指定顺讯执行
         > 2. newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1, 它使用LinkedBlockingQueue

       * Executors.newCachedThreadPool()  ====> 

         ```java
         ExecutorService threadPool = Executors.newCachedThreadPool();
                 try {
                     for (int i = 1; i < 10; i++) {
                         threadPool.execute(() -> {
                             System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                         });
                         try { TimeUnit.MILLISECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); }
                     }
                 }catch (Exception e) {
                     e.printStackTrace();
                 } finally {
                     threadPool.shutdown();
                 }
         //--------------------------------
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         ```

         ![image-20201225213521383](E:\learningNotes\面试专题\pic\image-20201225213521383.png)

         > 1. 创建一个可缓存的线程池, 如果线程池长度超过处理需要, 可灵活回收空闲线程, 若无可回收, 则创建新线程
         > 2. newCachedThreadPool将corePoolSize设置为0, 将maximumPoolSize设置为Integer.MAX_VALUE, 使用的synchronousQueue, 也就是说来了任务就创建线程运行, 当线程空闲时间超过60s就销毁线程

   * ThreadPoolExecutor



### 线程池用过吗?生产商你如何设置合理的参数?

### 死锁编码以及定位分析



