JAVA面试高频点

* JVM
* 多线程与高并发
* java集合类

![image-20201219111135414](E:\learningNotes\面试专题\pic\image-20201219111135414.png)



## JUC专题

### 一.请谈谈你对volatile的理解

1. volatile是java虚拟机提供的轻量级的同步机制

   * 保证可见性

     一个线程将共享变量修改完并写回到主内存, 其他的线程能立刻感知到

     ```java
     package com.interview.study.thread;
     import java.util.concurrent.TimeUnit
     class MyData {
         volatile int  number = 0;
         public void addT060() {
             this.number = 60;
         }
     }
     
     /**
      * 验证volatile的可见性
      * 1.没加volatile修饰number, 主线程永远不会打印, 因为其感知不到number被修改了
      * 2.使用volati,e修饰number, 主线程会打印, 因为其能感知到number被修改了
      */
     public class VolatileDemo {
         public static void main(String[] args) {
             MyData myData = new MyData();
             new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t come in");
                //暂停一会线程
                 try {
                     TimeUnit.SECONDS.sleep(3);
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
                 myData.addT060();
                 System.out.println(Thread.currentThread().getName() + "\t update number value:" + myData.number);
             }, "AAA").start();
     
             //主线程
             while (myData.number == 0) {
                 //只要number的值为0, 主线程就一直等待
             }
             System.out.println(Thread.currentThread().getName() + "\t misson over, get value:"+myData.number);//只要打印出这句话, 说明主线程已经感知到了number被修改
         }
     }
     ```

   * 不保证原子性

     ```java
     public static void automic() {
             MyData myData = new MyData();
     
             for (int i = 0; i < 20; i++) {
                 new Thread(() -> {
                     for (int j = 0; j <= 1000; j++) {
                         myData.addPlusPlus();
                     }
                 }, String.valueOf(i)).start();
             }
     
             /**
              * 等待全部计算线程计算完毕
              */
             while (Thread.activeCount() > 2) {
                 Thread.yield();
             }
     
             System.out.println(Thread.currentThread().getName() + "\t finally number value: " +  myData.number);
         }
     //main	 finally number value: 19844
     ```

     > number++在多线程环境是非线程安全的, 如何在不加synchonized的情况下保证原子性?
     >
     > ![image-20201219144133288](E:\learningNotes\面试专题\pic\image-20201219144133288.png)
     >
     > 加一操作在JVM中是三个操作
     >
     > 解决: syncchronized太重了, 使用automicInteger就可以保证加法的原子性

   * 禁止指令重排

     > 指令重排:
     >
     > 1. 单线程环境确保了程序最终执行结果和代码顺序执行的结果一致
     >
     > 2. 计算机在执行程序时, 为了提高性能, 编译器和处理器常常会对指令做重排, 一般分为一下三种:
     >
     > ​    **源代码 -> 编译器优化的指令重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令流**
     >
     > 3. 处理器在进行重排时需要考虑指令之间的**数据依赖性**.多线程环境中线程**交替执行**, 由于编译器优化重排的存在, 两个线程中使用的变量能否保证一致性是无法确定的, 结果无法预测
     >
     > 4. 禁止指令重排的原理:
     >
     >    在指令前插入一条Memory Barrier则会告诉编译器和CPU, 不管什么指令都不能喝这条Memory Barrier指令重排序, 也就是说通过插入内存屏障禁止在内存内存屏障前后的指令执行重排序优化. 内存屏障的另外一个作用是强制刷出各种CPU的缓存数据, 因此任何CPU上的线程都能读取到这些数据的最新版本

   > volatile实现了JMM内存模型规范中的两点, 可见性和有序性, 不保证原子性, syncronized保证原子性

2. 谈谈JMM(java内存模型)

   * 可见性
   * 原子性
   * 有序性

   jmm本身是一种抽象的概念, 并不真实存在, 他描述的是一种规则, 通过这种规则定义了程序中各个变量的访问方式

   `jmm关于同步的规定:`

   * 线程解锁前, 必须把共享变量的值刷新会主内存
   * 线程加速前, 必须读取主内存的最新值到自己的工作内存
   * 加锁和解锁是同一把锁

   > 由于jvm运行程序的实体是线程, 而每个线程创建时都会为其创建一个工作内存(栈空间), 工作内存是每个线程的私有数据区域, 而java内存模型中规定所有变量都存储在主内存中, 主内存是共享内存空间, 所有的线程都可以访问, 但是线程对变量的操作必须在工作内存中进行, 首先要将变量从主内存中拷贝到自己的工作内存, 然后读变量进行操作, 操作完成后在将变量写回主内存, 不能直接操作主内存中的变量, 各个线程中的工作内存中存储着主内存中的变量副本拷贝, 因此不同的线程间无法访问对方的工作内存, 线程间的通信必须通过主内存来完成
   >
   > ![image-20201219113437783](E:\learningNotes\面试专题\pic\image-20201219113437783.png)

3. 你在哪些地方用过volatile?

   * 单例模式DCL代码

     ```java 
     public class SingletonDemo {
         private static SingletonDemo instance = null;
     
         private  SingletonDemo() {
             System.out.println(Thread.currentThread().getName() + "\t 实例化");
         }
     
         private static SingletonDemo getInstance() {
             if (instance == null) {
                 instance = new SingletonDemo();
             }
             return instance;
         }
     
         public static void main(String[] args) {
     //        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
     //        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
     //        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
     
             for (int i = 1; i <= 10; i++) {
                 new Thread(()-> {
                     SingletonDemo.getInstance();
                 }, String.valueOf(i)).start();
             }
     
         }
     }
     //2	 实例化
     //4	 实例化
     //1	 实例化
     //3	 实例化
     //这种情况并不能保证单例
     ```

     > 使用synchronized修饰getInstance方法当然是可以保证单例的, 但是太重了. 我们其实需要锁的就只有`instance = new SingletonDemo();`这一行代码而已.因此加锁是需要的, 但是需要减小锁的粒度

     ```java
     private static SingletonDemo getInstance() {
             if (instance == null) {
                 synchronized (SingletonDemo.class) {
                     if (instance == null) {
                         instance = new SingletonDemo();
                     }
                 }
             }
             return instance;
         }
     ```

   * 单例模式volatile分析

     DCL机制不一定安全, 原因是指令重排的存在, 加入volatile可以禁止指令重排

     原因在于某一个线程执行到第一次检测, 读取到的instance不为null时, instance的引用对象可能没有完成初始化工作.

     instance = new SingletonDemo() 可以分为以下三步完成:

     * 为对象分配内存空间
     * 初始化对象
     * 设置instance指向刚分配的内存空间, 此时instance != null

     jvm为了指令执行效率, 会将第二步和第三步重排, 其他线程会拿到不为空, 但是实际上没有初始化完成的对象, 在执行其他操作时会有问题.需要给instance加上volatile

   ### CAS你知道吗?

   1. 比较并交换  **compare and swap**

      如果线程的期望值和主内存的值一样, 就将自己的修改值写会主内存.如果不一样, 写回失败

   2. CAS底层原理.如果知道, 请谈谈你对Unsafe的理解

      > 底层原理: 1.自旋锁 2.Unsafe类
      >
      > 工作原理: 比较当前工作内存中的额值和主内存中的值, 如果相同则执行规定操作, 否则继续比较知道主内存和工作内存中的值一致为止. 

      * automicInteger.getAndIncrement()

        ![image-20201219170934888](E:\learningNotes\面试专题\pic\image-20201219170934888.png)

        调用的是Unsafe中的方法

        ![image-20201219171138083](E:\learningNotes\面试专题\pic\image-20201219171138083.png)

      * Unsafe

        Unsafe是CAS的核心类, 由于java方法无法直接访问底层系统, 徐亚通过本地方法, native方法来访问, Unsafe相当于一个后门, 基于该类可以直接操作特定内存的数据.Unsafe类存在于sum.misc包中, 其内部方法操作可以像C语言的指针一样直接操作内存, 因为java中CAS操作的执行依赖于Unsafe类的方法.

        > Unsafe类中所有方法收拾native修饰的, 也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应的任务.valueOffset指的就是数据在内存中的地址, 且数据变量使用的是volatile关键字修饰的

      * CAS是什么(自旋)

        CAS全称为compare-and-swamp, 他是一条CPU并发原语.他的功能时判断内存中某个位置的值是否为预期值, 如果是则更改为新的值, 这个过程是原子的.

        CAS并发原语体现在java语言中就是sun.misc.Unsafe类中的各个方法. 调用Unsafe类中的CAS方法, JVM会帮我们实现CAS汇编指令. 这是一种完全依赖于硬件的功能, 通过他实现了原子操作. 由于CAS是一种系统原语, 原语属于操作系统用范畴, 是由若干条指令组成的, 用于完成某个功能的一个过程, 并且原语的执行必须是连续的, 在执行过程中不允许被终端, 也就是说CAS是CPU的一条原子指令, 不会造成数据不一致的问题.

        ![image-20201219172645329](E:\learningNotes\面试专题\pic\image-20201219172645329.png)

        在这里自旋了.比较失败后, 再获得该内存地址变量的最新值再比较, 此时若获取的是其他线程修改后的新值, 加法操作就会成功.否则再获得最新值作为自己的期望值, 再比较, 直至成功.

        > var1 AtomicInteger对象本身
        >
        > var2 该对象值的引用地址
        >
        > var4 需要变动的数量
        >
        > var5 该变量当前在内存中的真实值
        >
        > 用该对象的当前值和主内存中的该对象的值进行比较, 如果相同, 更新var5+var4并且返回true,
        >
        > 如果不同, 继续取值, 然后再比较, 直到更新完成

        为啥使用CAS而不是syncronized?

        后者虽然可以保证一直性, 但是并发度下降.使用CAS可以提高并发性.

        <img src="E:\learningNotes\面试专题\pic\image-20201219190454762.png" alt="image-20201219190454762" style="zoom: 67%;" />

        > compareAndSwampInt, 是一个本地方法, 该方法的实现位于Unsafe.cpp

        ![image-20201219190700222](E:\learningNotes\面试专题\pic\image-20201219190700222.png)

   3. CAS 缺点

      * 长时间自旋, CPU开销大
      * 只能保证一个共享变量的原子操作, 对于多个共享变量的操作只能通过syncronized来保证
      * ABA问题

### 二.原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗?

* 原子引用

  CAS算法实现的一个重要前提是需要取出内存中某时刻的数据并在当下时刻比较并替换, name在这个时间差内会导致数据的变化. 比如一个线程one从内存位置V取出A, 这个时候另一个线程two也从主内存重取出A, 并且线程two进行了一些操作将值变成B, 然后线程two又将V位置的数据变成A, 这时候线程one进行CAS操作发现内存中任然是A, 然后线程one操作成功.**尽管线程one的CAS操作成功, 但是不代表这个过程是没问题的**

* 原子引用

  ```java
  package com.interview.study.thread;
  
  
  import java.util.concurrent.atomic.AtomicReference;
  
  class User {
      String userName;
      int age;
  
      public User(String userName, int age) {
          this.userName = userName;
          this.age = age;
      }
  
      public String getUserName() {
          return userName;
      }
  
      public void setUserName(String userName) {
          this.userName = userName;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "User{" +
                  "userName='" + userName + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  public class AtomicReferenceDemo {
      public static void main(String[] args) {
          User z3 = new User("z2", 23);
          User li4 = new User("li4", 24);
          AtomicReference<User> atomicReference = new AtomicReference<>();
          atomicReference.set(z3);
          System.out.println(atomicReference.compareAndSet(z3, li4) + "\t " + atomicReference.get().toString());
      }
  }
  //true	 User{userName='li4', age=24}
  ```

  * 时间戳原子引用

### 三.我们知道ArrayList是线程不安全的, 请编写一个不安全的案例, 并给出解决方案

```java
/**
 * 集合类不安全的问题
 */
public class ContainerNotSafeDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
//	java.util.ConcurrentModificationException
```

vector加了synchronized, 不会报错, 但是性能不好

1. 导致原因

   多个线程并发修改

2. 解决方案

   * new vector<>() :x:

   * Collections.synchronizedList(new ArrayList<>());  :x:

   * new CopyOnWriteArrayList<>() :heavy_check_mark:

     写时复制, 读写分离的思想

     ```java
     public boolean add(E e) {
             final ReentrantLock lock = this.lock;
             lock.lock();
             try {
                 Object[] elements = getArray();
                 int len = elements.length;
                 Object[] newElements = Arrays.copyOf(elements, len + 1);
                 newElements[len] = e;
                 setArray(newElements);
                 return true;
             } finally {
                 lock.unlock();
             }
         }
     ```

     > CopyOnWrite容器即写时复制的容器. 向一个容器中添加元素时, 不直接向当前同期Object[]中添加, 而是先将当前容器Object[]进行copy, 复制出一个新的额容器Object[] , 然后向新的容器中添加元素, 添加完后将原容器的引用指向新的容器.这样做的好处是可以对CopyOnWrite容器进行并发的读, 而不需要加锁, 因为当前容器不会添加任何新的元素, 所以是一种读写分离的思想, 读和写不同的容器(**适合写少读多的场景**)

3. 集合类不安全之set

   ```java
   public class ContainerNotSafeDemo {
       public static void main(String[] args) {
           Set<String> set  = new HashSet<>();
   
           Collections.synchronizedList(new ArrayList<>());
           for (int i = 0; i < 30; i++) {
               new Thread(()->{
                   set.add(UUID.randomUUID().toString().substring(0, 8));
                   System.out.println(set);
               }, String.valueOf(i)).start();
           }
       }
   }
   // java.util.ConcurrentModificationException
   ```

   new CopyOnWriteArraySet<>()底层使用的也是CopyOnWriteArrayList

   HashSet底层是用HashMap实现的, 之所以只用添加一个值(map中的key), 是因为value是一个对象常量

4. 集合类不安全之map

   使用concurrentHashMap :question:

### 四.公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解? 请手写一个自旋锁

1. 公平锁/非公平锁

   * 公平锁 是指多个线程按照申请锁的顺序来获取锁, 先来后到   new ReetrantLock(true)

   * 非公平锁 是指多个线程获取锁的顺序并不会按照申请锁的顺序, 有可能后申请的线程比先申请的线程优先获取锁. 在高并发场景下可能会造成优先级反转或者饥饿现象  new ReetrantLock(false).其优点在于吞吐量大.**对于syncchronized而言, 其也是一种非公平锁**

     > 非公平锁上来直接尝试占用锁, 如果尝试失败, 再采用类似公平锁的那种方式

2. 可重入锁(递归锁)

   * 是什么

     指的是同一线程外层函数获得锁之后, 内层递归函数仍然能获取该锁的代码

     在同一个线程在外层方法获取锁的时候, 在进入内层方法会自动获取锁  

     也就是说, 线程可以进入任何一个它已经拥有的锁所同步着的代码块

   * ReentrantLock/Syncchronized 就是一个典型的可重入锁

   * 可重入锁的最大的作用是避免死锁

   * demo

     syncchronized是一种可重入锁

     ```java
     class Phone {
         public synchronized static void sendSms() throws Exception {
             System.out.println(Thread.currentThread().getName() + "\t invokr sendSms");
             sendMail();
         }
     
         public synchronized static void sendMail() throws Exception {
             System.out.println(Thread.currentThread().getName() + "\t invoke sendMail");
         }
     }
     public class ReentrantLockDemo {
         public static void main(String[] args) {
             Phone phone = new Phone();
     
             new Thread(()->{
                 try {
                     phone.sendSms();
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }, "t1").start();
     
             new Thread(()->{
                 try {
                     phone.sendMail();
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }, "t2").start();
         }
     }
     //------------------------
     t1	 invokr sendSms
     t1	 invoke sendMail
     t2	 invoke sendMail
     //两个线程并发执行, t1在获得sms方法的锁之后自动获取了mail方法的锁. 所以t2线程如果一开始就没有抢mail的锁, 因为两个锁是一把锁, t2只能等待t1将两个方法全部执行完成后才能抢占mail方法的锁, 然后执行mail 方法
     ```

     ReentrantLock

     ```java 
     class Phone2 implements Runnable {
     
         Lock lock = new ReentrantLock();
         @Override
         public void run() {
             get();
         }
     
         public void get() {
             lock.lock();
             try {
                 System.out.println(Thread.currentThread().getName() + "\t invoke get");
                 set();
             } finally {
                 lock.unlock();
             }
         }
     
         public void set() {
             lock.lock();
             try {
                 System.out.println(Thread.currentThread().getName() + "\t invoke set");
             } finally {
                 lock.unlock();
             }
         }
     }
     
     public class ReentrantLockDemo {
         public static void main(String[] args) {
             Phone2 phone2 = new Phone2();
     
             Thread t3 = new Thread(phone2, "t3");
             Thread t4 = new Thread(phone2, "t4");
             t3.start();
             t4.start();
         }
     }
     //-----------------------
     t3	 invoke get
     t3	 invoke set
     t4	 invoke get
     t4	 invoke set
     ```

     > 加几把锁无所谓, 但是加锁和释放锁要匹配

3. 自旋锁

   指的是尝试获取锁定额线程在没有获取到锁的情况下, 不会立即阻塞(:exclamation:), 而是采取循环的方式尝试获取锁, 这样的好处:

   **减少线程上下文切换的消耗,** 

   缺点:

   **会消耗CPU**

   ![image-20201220140105052](E:\learningNotes\面试专题\pic\image-20201220140105052.png)
   
4. 手动实现自旋锁

   ```java
   public class SpinLockDemo {
   
       AtomicReference<Thread> atomicReference = new AtomicReference<>();
   
       public void myLock() {
           Thread thread = Thread.currentThread();
           System.out.println(Thread.currentThread().getName() + "\t invoke lock");
           while(!atomicReference.compareAndSet(null, thread)) {
               System.out.println(Thread.currentThread().getName() + "\t 获取失败, 自旋");
           }
           System.out.println(Thread.currentThread().getName() + "\t 获取成功");
       }
   
       public void muUnlock() {
           Thread thread = Thread.currentThread();
           atomicReference.compareAndSet(thread, null);
           System.out.println(Thread.currentThread().getName() + "\t invoke unlock");
       }
   
       public static void main(String[] args) {
           SpinLockDemo spinLockDemo = new SpinLockDemo();
           new Thread(()->{
               spinLockDemo.myLock();
               try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
               spinLockDemo.muUnlock();
           }, "AA").start();
   
   
           try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
   
           new Thread(()->{
               spinLockDemo.myLock();
               spinLockDemo.muUnlock();
           }, "BB").start();
       }
   }
   //--------------------
   AA	 invoke lock
   AA	 获取成功
   BB	 invoke lock
   AA	 invoke unlock
   BB	 获取成功
   BB	 invoke unlock
   ```

5. 独占锁(:exclamation:写锁)/共享锁(:exclamation:读锁)/互斥锁

   * 独占锁

     指的是该锁一次只能被一个线程所持有. 对ReentrantLock和synchronized而言都是独占锁

   * 共享锁

     指该所可以被多个线程锁持有

     对**ReenTrantReadWriteLock**其读锁是共享锁, 其写锁是独占锁

     读锁的共享锁可保证并发读是非常高效的, 读写, 写读, 写写的过程是互斥的

     > 多个线程同时读一个资源类没有问题, 所以为了满足并发量, 读取共享资源应该可以同时进行.
     >
     > 但是:
     >
     > 如果一个线程想去写共享资源来, 就不应该再有其他线程可以对该资源进行读或者写
     >
     > 小总结:
     >
     > ​	读-读能共存
     >
     > ​	读-写不能共存
     >
     > ​	写-写不能共存

     资源类未加读写锁

     ```java
     class MyCache1 {//资源类
         private volatile Map<String, Object> map = new HashMap<>();//多线程写必须使用volatile修饰共享变量
         public void put(String key, Object value) {
             System.out.println(Thread.currentThread().getName() + "\t 正在写入" + key);
             try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
             map.put(key, value);
             System.out.println(Thread.currentThread().getName() + "\t 写入完成");
         }
     
         public void get(String key) {
             System.out.println(Thread.currentThread().getName() + "\t 正在读取" + key);
             try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
             map.get(key);
             System.out.println(Thread.currentThread().getName() + "\t 读取完成");
         }
     }
     
     public  static void notsafe() {
             MyCache1 myCache = new MyCache1();
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.put(tmpInt+"", tmpInt);
                 }, String.valueOf(i)).start();
             }
     
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.get(tmpInt+"");
                 }, String.valueOf(i)).start();
             }
         }
     //-----------------------------
     1	 正在写入1
     2	 正在写入2
     3	 正在写入3
     5	 正在写入5
     4	 正在写入4
     3	 正在读取3
     5	 正在读取5
     4	 正在读取4
     1	 正在读取1
     2	 正在读取2
     3	 写入完成
     2	 读取完成
     1	 写入完成
     3	 读取完成
     4	 读取完成
     5	 读取完成
     1	 读取完成
     5	 写入完成
     4	 写入完成
     2	 写入完成
     ```

     资源类加上读写锁

     ```java
     class MyCache2 {//资源类
         private volatile Map<String, Object> map = new HashMap<>();//多线程写必须使用volatile修饰共享变量
         private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
         public void put(String key, Object value) {
     
             readWriteLock.writeLock().lock();//写锁加锁, 再次期间不能读写
             try {
                 System.out.println(Thread.currentThread().getName() + "\t 正在写入" + key);
                 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
                 map.put(key, value);
                 System.out.println(Thread.currentThread().getName() + "\t 写入完成");
             } finally {
                 readWriteLock.writeLock().unlock();//写锁释放
             }
     
         }
     
         public void get(String key) {
             readWriteLock.readLock().lock();//写锁加锁, 再次期间可读不可写
             try {
                 System.out.println(Thread.currentThread().getName() + "\t 正在读取" + key);
                 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }//模拟网络拥堵的情况
                 map.get(key);
                 System.out.println(Thread.currentThread().getName() + "\t 读取完成");
             } finally {
                 readWriteLock.readLock().unlock();//写锁释放
             }
         }
     }
     public  static void safe() {
             MyCache2 myCache = new MyCache2();
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.put(tmpInt+"", tmpInt);
                 }, String.valueOf(i)).start();
             }
     
             for (int i = 1; i <= 5 ;i++) {
                 final int tmpInt = i;
                 new Thread(()->{
                     myCache.get(tmpInt+"");
                 }, String.valueOf(i)).start();
             }
         }
     //----------------------
     1	 正在写入1
     1	 写入完成
     4	 正在写入4
     4	 写入完成
     2	 正在写入2
     2	 写入完成
     3	 正在写入3
     3	 写入完成
     5	 正在写入5
     5	 写入完成
     3	 正在读取3
     1	 正在读取1
     4	 正在读取4
     2	 正在读取2
     5	 正在读取5
     4	 读取完成
     2	 读取完成
     5	 读取完成
     3	 读取完成
     1	 读取完成
     ```

### 五.CountDownLatch/CycliBarrier/Semaphore使用过吗?

1. CountDownLatch

* 定义

  让一些线程阻塞知道另一些线程完成一系列操作后才被唤醒

* 工作原理

  countDownLatch主要由两个方法, 当一个或者多个线程调用await方法时, 调用线程会被阻塞.其他线程调用countDo恩方法时会将计数器减一(调用countDown方法的线程不会阻塞), 当计数器值减为零时,, 因调用await方法被阻塞的线程会被唤醒继续执行

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for (int i = 1; i <= 5 ;i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t 上完自习, 离开教室");
                countDownLatch.countDown();
            }, String.valueOf(i)).start();
        }
        countDownLatch.await();//在这个位置等待所有的线程执行完成, 主线程才继续向下走
        System.out.println(Thread.currentThread().getName() + "\t 班长关门走人");
    }
}
//-------------------------
1	 上完自习, 离开教室
5	 上完自习, 离开教室
4	 上完自习, 离开教室
3	 上完自习, 离开教室
2	 上完自习, 离开教室
main	 班长关门走人
```

在解耦中使用枚举类

```java
public  enum CountyEnum {
    ONE(1, "齐国"), TWO(2, "楚国"),THREE(3, "燕国"),FOUR(4 ,"赵国"),FIVE(5, "韩国");

    private Integer retcode;
    private String retMsg;

    CountyEnum(Integer retcode, String retMsg) {
        this.retcode = retcode;
        this.retMsg = retMsg;
    }

    public Integer getRetcode() {
        return retcode;
    }

    public String getRetMsg() {
        return retMsg;
    }

    public static CountyEnum forEach_CountryEnum(int index) {
        CountyEnum[] myArray = CountyEnum.values();
        for (CountyEnum element: myArray) {
            if (index == element.getRetcode()) {
                return element;
            }
        }
        return null;
    }
}
```

2. CyclicBarrier

   可训话使用的屏障. 他要做的事情是, 让一组线程到达一个屏障时被阻塞, 知道最后一个线程到达屏障时, 屏障才会打开, 所有被屏障拦截的线程才能继续运行, 线程进入屏障通过CyclicBarrier的await方法	

   ```java
   public class CyclicBarrierDemo {
       public static void main(String[] args) {
           CyclicBarrier cyclicBarrier = new CyclicBarrier(7, ()->{ System.out.println("*******召唤神龙");});
   
           for (int i = 1; i <= 7 ;i++) {
               final int tmpInt = i;
               new Thread(()->{
                   System.out.println(Thread.currentThread().getName() + "\t 收集" + tmpInt +" 龙珠");
                   try {
                       cyclicBarrier.await();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   } catch (BrokenBarrierException e) {
                       e.printStackTrace();
                   }
               }, String.valueOf(i)).start();
           }
       }
   ```

3. Semaphore

   信号量主要用于两个目的, 一个是用于**多个共享资源的互斥使用**:exclamation:, 另一个用于**并发线程数的控制**:exclamation:

   ```java
   public class SemaphoreDemo {
       public static void main(String[] args) {
           Semaphore semaphore = new Semaphore(3);//三个车位
   
           for (int i = 1; i <= 6;i++) {//6个车抢3个车位
               new Thread(()->{
                   try {
                       semaphore.acquire();//尝试占用车位
                       System.out.println(Thread.currentThread().getName() + "\t 抢到车位");
                       try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
                       System.out.println(Thread.currentThread().getName() + "\t 停车3秒后离开");
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   } finally {
                       semaphore.release();//释放被占用的资源
                   }
               }, String.valueOf(i)).start();
           }
       }
   ```

   

### 六.阻塞队列知道吗

1. 队列 + 阻塞队列

   <img src="E:\learningNotes\面试专题\pic\image-20201220163433598.png" alt="image-20201220163433598" style="zoom:50%;" />

   > 当阻塞队列是空时, 从队列中获取元素的操作将会被阻塞
   >
   > 当阻塞队列 是满时, 向队列中添加元素的操作将会被阻塞

2. 有什么好处?

   在多线程领域, 所谓阻塞, 在某些情况下, 会挂起线程, 一旦条件满足, 被挂起的线程又会被自动唤醒

   好处:

   我们不需要关心什么时候需要阻塞线程, 什么时候需要唤醒线程, 这一切已经被BlockingQueue封装了

   在concurrent包发布以前, 在多线程环境下, 我们每个程序员都必须自己去控制这些细节, 尤其还要兼顾效率和线程安全, 而这会给我们的程序代码不小的复杂度.

3. BlockingQueue的核心方法

   ![image-20201220164407562](E:\learningNotes\面试专题\pic\image-20201220164407562.png)

   <img src="E:\learningNotes\面试专题\pic\image-20201220165411617.png" alt="image-20201220165411617" style="zoom:50%;" />

   * 抛出异常

     add 队列满抛出异常,remove  队列中没有元素时移除抛出异常, element 检查队列是否为空, 若不为空返回队首元素

   * 特殊值

     offer 向队列中添加元素, 如果添加成功返回true, 否则返回false; peek() 返回队首元素但不将其从队列中移除; poll 从队列中弹出元素, 若队列为空, 返回null

   * 阻塞

     put 向队列中添加元素, 如果队列满了, 就阻塞一直等待, 知道队列中有元素被消费空出位置然后再将元素放入队列; take 从队列中取出元素, 如果队列为空就一直等待, 直到队列中有元素供消费

   * 超时

     offer 向队列中添加元素, 如果队列满了, 就等待固定时间, 如果在此时间内队列仍然是满的, 就退出; poll

     从队列中取元素, 如果队列为空, 就等到固定时间, 如果再次时间内队列中仍然没有元素供消费就退出;

   

4. 种类

   * ArrayBlockingQueue: 由数组结构组成的有界阻塞队列:heavy_check_mark:

   * LinkedBlockingQueue: 由链表结构组成的有界阻塞队列(大小默认为**Integer.MAX_VALUE**):heavy_check_mark:

   * PriorityBlockingQueue: 支持优先级排序的误解阻塞队列

   * DelayQueue: 使用优先级队列实现的延迟无界阻塞队列

   * SynchronousQueue: 不存储元素的阻塞队列, 也就是单个元素的队列:heavy_check_mark:

     不存储元素的阻塞队列. 每个put操作必须要等待一个take操作, 否则不能继续添加元素, 反之亦然

     ```java
     public class SynchronousQueueDemo {
         public static void main(String[] args) {
             BlockingQueue<String> blockingQueue = new SynchronousQueue<>();
     
             new Thread(()->{
                 for (int i = 1; i <=3 ; i++) {
                     System.out.println(Thread.currentThread().getName() + "\t put" + i);
                     try {
                         blockingQueue.put(1 + "");
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                 }
             }, "AAA").start();
     
             new Thread(()->{
                 for (int i = 1; i <=3 ; i++) {
                     try {
                         try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
                         System.out.println(Thread.currentThread().getName() + "\t get" + i);
                         blockingQueue.take();
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                 }
             }, "BBB").start();
         }
     }
     //---------------------
     AAA	 put1
     BBB	 get1
     AAA	 put2
     BBB	 get2
     AAA	 put3
     BBB	 get3
     ```

   * LinkedTransFerQueue: 由链表结构组成的无界阻塞队列

   * LinkedBlocking**Deque**: 由链表组成的:exclamation: **双向**:exclamation: 阻塞队列

   > 打钩的三个是重点, 线程池的底层实现

5. 用在哪里

   * 生产者消费者模式

     * 传统版

       ```java
       class ShareData {
           private int number = 0;
           private Lock lock = new ReentrantLock();
           private Condition condition = lock.newCondition();
       
           public  void increment() {
               lock.lock();
               //1.判断
               try {
                   while (number != 0) {
                       condition.await();
                   }
                   //2.干活
                   number++;
                   System.out.println(Thread.currentThread().getName() + "\t" +number);
                   //3.通知唤醒
                   condition.signalAll();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               } finally {
                   lock.unlock();
               }
           }
       
           public  void decrement() {
               lock.lock();
               //1.判断
               try {
                   while (number == 0) {
                       condition.await();
                   }
                   //2.干活
                   number--;
                   System.out.println(Thread.currentThread().getName() + "\t" +number);
                   //3.通知唤醒
                   condition.signalAll();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               } finally {
                   lock.unlock();
               }
           }
       
       }
       public class ProducerConsumer_TransactionalDemo {
           public static void main(String[] args) {
               ShareData shareData = new ShareData();
       
               new Thread(()->{
                   for (int i = 1; i <=5 ; i++) {
                       shareData.increment();
                   }
               }, "AAA").start();
       
               new Thread(()->{
                   for (int i = 1; i <=5 ; i++) {
                       shareData.decrement();
                   }
               }, "BBB").start();
           }
       }
       //---------------------
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       AAA	1
       BBB	0
       ```

       

     * 阻塞队列版

       ```java
       class MyResource {
           private volatile boolean FLAG = true;
           private AtomicInteger atomicInteger = new AtomicInteger();
       
           BlockingQueue<String> blockingQueue = null;
       
           public MyResource(BlockingQueue<String> blockingQueue) {
               this.blockingQueue = blockingQueue;
               System.out.println(blockingQueue.getClass().getName());
           }
       
           public void myProd() throws Exception {
               String data = null;
               boolean retCode;
               while(FLAG) {//只要生产线没有停止就一直生产
                   data = atomicInteger.incrementAndGet() + "";
                   retCode = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
                   if (retCode) {
                       System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "成功");
                   } else {
                       System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "失败");
                   }
                   TimeUnit.SECONDS.sleep(1);
               }
               System.out.println(Thread.currentThread().getName() + "\t 生产结束");
           }
       
           public void myConsumer() throws Exception {
               String result = null;
               while (FLAG) {
                   result = blockingQueue.poll(2L, TimeUnit.SECONDS);
                   if (null == result || result.equalsIgnoreCase("")) {//生产者停止生产, 消费者退出
                       FLAG = false;
                       System.out.println(Thread.currentThread().getName() + "\t 消费超时, 消费者结束消费");
                       return;
                   }
                   System.out.println(Thread.currentThread().getName() + "\t 消费队列" + result + "成功");
               }
           }
       
           public void stop() throws Exception {//叫停生产者消费者
               this.FLAG = false;
           }
       }
       
       
       public class ProducerConsumer_BlokingQueueDemo {
           public static void main(String[] args) throws Exception {
       
               MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
               new Thread(()->{
                   try {
                       System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
                       myResource.myProd();
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }, "producer").start();
       
               new Thread(()->{
                   try {
                       System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
                       myResource.myConsumer();
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }, "consumer").start();
       
               try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
       
               System.out.println("生产结束, 生产线停止运行......");
               myResource.stop();
           }
       }
       ```

       

   * 线程池

   * 消息中间件

> 1. 线程   操作   资源类
>
> 2. 判断   干活   唤醒通知
>
> 3. 严防多线程状态下的虚假唤醒

5. synchronized 和lock有什么区别?用新的 lock有什么好处?

   * 原始构成:

     synchronized 是JVM层面, 是java语言的关键字 monitorenter(底层是通过monitor对象来完成, 其中wait/notify等方法也依赖于monitor对象只有在同步块或方法中才能调wait/notify等方法); 

     lock是api层面的锁

   * 使用方法

     synchronized 不需要用户手动释放锁, 当synchronized代码执行完后系统会自动让线程释放对象锁的占用(monitorexit)

     ReentrantLock 则需要用户去手动释放锁, 如果没有主动释放锁, 就有可能会导致死锁

   * 是否可中断

     synchronized不可中断, 除非抛出异常或者正常运行完

     ReentrantLock 可中断, lockInterruptibly()放在代码块中, 调用interrupt方法即可

   * 加锁是否公平

     synchronized是非公平锁

     ReentrantLock两者都可以, 默认是非公平锁, 构造方法可以传入boolean值, true为公平锁, false是非公平锁

   * 锁绑定多个条件Condition

     synchronized没有condition

     ReentrantLock用来实现分组唤醒需要唤醒的线程们, 可以精确唤醒, 而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程

### 七.线程池用过吗?ThreadPoolExecutor谈谈你的理解?

1. Runnable和Callable接口的区别

   * Runnable无返回值, Callable有返回值

     ```java
     class MyThread2 implements Callable<Integer> {
         @Override
         public Integer call() throws Exception {
             return null;
         }
     }
     ```

     > Thread 类的构造方法中只能传Runnable接口, 如果我们想在构造一个线程的时候传入Callable使其可以返回值怎么做呢? 这个时候就需要一个类同时实现Runnable接口和Callable接口, 在构造一个Thread的时候将new 出来的Thread传入到这个类的构造方法中. 这个同时实现了Runnable接口和Callable的类就是FutureTask接口(适配器模式)

     ```java
     FutureTask<Integer> futureTask = new FutureTask<>(new MyThread2());
     Thread t1 = new Thread(futureTask, "AAA");
     t1.start();
     System.out.println("result: " + futureTask.get());
     ```

     > 为什么要使用callable和futureTask?
     >
     > 异步任务, 当线程运行结束后接受其返回值, 尽量避免阻塞.
     >
     > 由于futureTask.get()会阻塞, 所以尽量将其放在使用返回值的代码处.
     >
     > 也可以使用futureTask.isDone() 判断callable接口是否计算完成, 如果没有计算完成, 就循环, 这样比阻塞的性能会更好点.自旋性能 > 阻塞

     ```java
     FutureTask<Integer> futureTask = new FutureTask<>(new MyThread2());
     
     Thread t1 = new Thread(futureTask, "AAA");
     Thread t2 = new Thread(futureTask, "AAA");
     t1.start();
     t2.start();
     Integer result2 = 1014;
     while (!futureTask.isDone()) {
     
     }
     Integer result1 = futureTask.get();
     System.out.println("result: " + (result1 + result2));
     //----------------------------------
     AAA*************come in callable***************
     result: 2038
     ```

     > 上述代码中, t2不会进入线程, 因为jvm认为和t1的任务相同, 无需做重复的计算
     >
     > 结论:
     >
     > **多个线程抢一个futuretask只会有一个抢到并运行, 另外一个不会运行**

2. 为什么用线程池, 优势有哪些?

   * 什么是线程池

     线程池做的工作主要是控制运行的线程的数量, 处理过程中将任务放在队列中, 然后在线程创建后启动这些任务, 如果线程的最大数量超出了数量的线程排队等候, 再从队列中取出任务来运行

   * 优势(线程复用, 控制最大并发数, 管理线程)

     * 降低资源消耗. 通过重复利用已创建的线程降低线程创建和销毁造成的消耗
     * 提高响应速度. 当任务到达时, 任务可以不需要等到线程创建就能立即执行
     * 提高线程的可管理性. 线城市稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 调优和监控

3. 线程池如何使用

   * 架构说明

     java 中的线程池是通过Executor框架实现的, 该框架中用到了Executor, Executors, ExecutorService, ThreadPoolExecutor这几个类

     <img src="E:\learningNotes\面试专题\pic\image-20201225210513352.png" alt="image-20201225210513352" style="zoom:50%;" />

     <img src="E:\learningNotes\面试专题\pic\image-20201225210604993.png" alt="image-20201225210604993" style="zoom:50%;" />

     > 两个核心重点: 1.**Executors** 2.**ThreadPoolExecutor**
     >
     > Array ====> Arrays
     >
     > Collection ====> Collections
     >
     > Executor ====> Executors
     >
     > 接口  ====>  辅助工具类

     > 到目前为止可以获得线程的方式:
     >
     > 1. new Thread
     >
     > 2. 实现Runnable接口重写run方法
     >
     >    没有返回值, 不抛异常
     >
     > 3. 实现Callable接口重写call方法
     >
     >    有返回值, 会抛异常
     >
     > 4. 使用线程池

   * 编码实现

     * 了解

       * Executors.newScheduledThreadPool()

         带调度的线程池(池子中的任务隔一段时间执行一次)

       * Executors.newWorkStealingPool(int)

         java8新增, 使用目前机器上可用的处理器作为他的并行级别

     * **重点**(下面三个的底层实现都是**ThreadPoolExecutor**)

       * Executors.newFixedThreadPool(int)  ====> 线程池中固定线程数的线程

         > **适合执行长期的任务, 性能好很多**:heavy_check_mark:
       
         ```java
         ExecutorService threadPool = Executors.newFixedThreadPool(5);
                 try {
                     for (int i = 1; i < 10; i++) {
                         threadPool.execute(() -> {
                             System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                         });
                     }
                 }catch (Exception e) {
                     threadPool.shutdown();
                 }
         //-------------------------
         pool-1-thread-1	 办理业务
         pool-1-thread-5	 办理业务
         pool-1-thread-4	 办理业务
         pool-1-thread-3	 办理业务
         pool-1-thread-2	 办理业务
         pool-1-thread-3	 办理业务
         pool-1-thread-4	 办理业务
         pool-1-thread-5	 办理业务
    pool-1-thread-1	 办理业务
         ```

         ![image-20201225213134796](E:\learningNotes\面试专题\pic\image-20201225213134796.png)
       
    > 1. 创建一个定长线程池, 可控制最大并发数, 超出的线程会在线程中等待
   
      > 2. newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的
   
       * Executors.newSingleThreadExecutor()  ====>  
       
         > 一个任务一个任务顺序执行的场景:heavy_check_mark:
       
         ```java
         ExecutorService threadPool = Executors.newSingleThreadExecutor();
                 try {
                     for (int i = 1; i < 10; i++) {
                         threadPool.execute(() -> {
                             System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                         });
                     }
                 }catch (Exception e) {
                     e.printStackTrace();
                 } finally {
                     threadPool.shutdown();
                 }
         //-------------------------------
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
    pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
    pool-1-thread-1	 办理业务
         ```
       
    ![image-20201225213311081](E:\learningNotes\面试专题\pic\image-20201225213311081.png)
       
    > 1. 创建一个单线程化的线程池, 它只会用唯一的工作线程来执行任务, 保证所有的任务按照指定顺讯执行
   
         > 2. newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1, 它使用LinkedBlockingQueue
       
       * Executors.newCachedThreadPool()  ====> 
       
         > **执行很多短期异步的小程序或者负载较轻的服务器**:heavy_check_mark:
         
         ```java
         ExecutorService threadPool = Executors.newCachedThreadPool();
                 try {
                     for (int i = 1; i < 10; i++) {
                         threadPool.execute(() -> {
                             System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                         });
                         try { TimeUnit.MILLISECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); }
                     }
                 }catch (Exception e) {
                     e.printStackTrace();
                 } finally {
                     threadPool.shutdown();
                 }
         //--------------------------------
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
    pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
    pool-1-thread-1	 办理业务
         pool-1-thread-1	 办理业务
       pool-1-thread-1	 办理业务
      ```
       
         ![image-20201225213521383](E:\learningNotes\面试专题\pic\image-20201225213521383.png)
         
         > 1. 创建一个可缓存的线程池, 如果线程池长度超过处理需要, 可灵活回收空闲线程, 若无可回收, 则创建新线程
         > 2. newCachedThreadPool将corePoolSize设置为0, 将maximumPoolSize设置为Integer.MAX_VALUE, 使用的synchronousQueue, 也就是说来了任务就创建线程运行, 当线程空闲时间超过60s就销毁线程
   
   * ThreadPoolExecutor
      ```
   
4. 线程池的几个重要参数介绍?(7大参数)

   ![image-20201226103256129](E:\learningNotes\面试专题\pic\image-20201226103256129.png)

   * corePoolSize: 线程池的常驻核心线程数

   * maximumPoolSize: 线程池能够容纳同时执行的最大线程数, 此值必须大于等于1

     > **corePoolSize**个线程都在执行任务且阻塞队列也满了, 这个时候提交了新的任务, 线程池会扩容, 扩容的容量小于等于**maximumPooLSize**

   * keepAliveTime: 多余的空闲线程的存活时间

     > 当线程池中线程数量超过corePoolSize时, 当线程的空闲时间达到keepAliveTime时, 多余的空闲线程会被销毁知道剩下corePoolSize个线程为止
     >
     > 默认情况下, 只有当线程池中的线程数大于corePoolSize时, KeepAliveTime才会起作用, 知道线程池中的线程数不大于corePoolSize

   * unit: keepAliveTime的时间单位

   * workQueue: 任务队列, 被提交但是尚未被执行的任务

   * threadFactory: 表示生成线程池中工作线程的线程工厂, 用于创建线程一般使用默认的

   * Handler: 拒绝策略, 表示当队列满并且工作线程大于等于线程池的最大线程数

     > 当线程池中工作线程数量等于maximum并且阻塞队列满了, 开始执行拒绝提交的任务	
     >
     > 四大拒绝策略:
     >
     > * AbortPolicy: **报异常**
     > * DiscardPolicy: 
     > * CallerRunsPolicy:
     > * DiscardOldestPolicy:

5. 说说线程池的底层工作原理

   <img src="E:\learningNotes\面试专题\pic\image-20201226105858343.png" alt="image-20201226105858343" style="zoom:50%;" />

   <img src="E:\learningNotes\面试专题\pic\image-20201226110413107.png" alt="image-20201226110413107" style="zoom:50%;" />

   > 总结来说就是:
   >
   > <img src="E:\learningNotes\面试专题\pic\image-20201226110618848.png" alt="image-20201226110618848" style="zoom:50%;" />

   

### 八.线程池用过吗?生产商你如何设置合理的参数?

1. 线程池的拒绝策略, 请你谈谈

   * 是什么

     等待队列满了, 再也塞不下新任务了, 同时线程池中的max线程数也达到了, 无法为新任务服务. 这个时候我们就需要拒绝策略机制合理的处理这个问题

   * jdk内置的拒绝策略

     * AbortPolicy: 直接抛出异常RejectedExecutionException 异常阻止系统正常运行
     * CallerRunsPolicy: 调用者运行的一种调节机制, 该策略既不会抛弃任务以也不会抛出异常, 而是将某些任务会退给调用者(主线程), 从而降低新任务的流量
     * DiscardOldestPloicy: 抛弃队列中等待最久的任务, 然后把当前任务加入队列中尝试再次提交当前任务
     * DiscardPolicy: 直接丢弃任务, 不予任务处理也不抛出异常.如果允许任务丢失, 这是最好的一种方案.

2. 你在工作中使用哪种线程池

   一个都不用, 生产上只使用自定义的

   > **线程池不允许使用Executors去创建, 而是通过ThreadPoolExecutor的方式** :exclamation: 
   >
   > * FixedThreadPool和SingleThreadPool允许的请求队列长度为Integer.MAX_VALUE, 可能会堆积大量的请求, 从而导致OOM
   > * CachedThreadPool和ScheduledThreadPool允许的请求队列长度为Integer.MAX_VALUE, 可能会堆积大量的请求, 从而导致OOM

3. 你在工作中是如何使用线程池的, 是否自定义过线程池的使用

   ```java
   public static void main(String[] args) {
           ExecutorService threadPool = new ThreadPoolExecutor(
                   2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(3), new ThreadPoolExecutor.AbortPolicy());
           try {
               for (int i = 1; i <= 9; i++) {
                   threadPool.execute(() -> {
                       System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                   });
               }
           }catch (Exception e) {
               e.printStackTrace();
           } finally {
               threadPool.shutdown();
           }
       }
   //-----------------------------
   pool-1-thread-2	 办理业务
   pool-1-thread-2	 办理业务
   pool-1-thread-2	 办理业务
   pool-1-thread-2	 办理业务
   pool-1-thread-1	 办理业务
   pool-1-thread-3	 办理业务
   pool-1-thread-4	 办理业务
   pool-1-thread-5	 办理业务
   java.util.concurrent.RejectedExecutionException: Task com.interview.study.thread.MyThreadPoolDemo$$Lambda$1/1078694789@3b9a45b3 rejected from java.util.concurrent.ThreadPoolExecutor@7699a589[Running, pool size = 5, active threads = 4, queued tasks = 0, completed tasks = 2]
   	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
   	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
   	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
   	at com.interview.study.thread.MyThreadPoolDemo.main(MyThreadPoolDemo.java:14)
   ```

   > 当提交的任务的数量大于线程池maximum线程数 + 阻塞队列大小, 就会触发线程池的拒绝策略. 上面提交了9个任务 > 5(线程池最大线程数) + 3(阻塞队列大小). 上面使用的是默认的AbortPolicy

   ```java
   public static void main(String[] args) {
           ExecutorService threadPool = new ThreadPoolExecutor(
                   2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(3), new ThreadPoolExecutor.CallerRunsPolicy());
           try {
               for (int i = 1; i <= 9; i++) {
                   threadPool.execute(() -> {
                       System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                   });
               }
           }catch (Exception e) {
               e.printStackTrace();
           } finally {
               threadPool.shutdown();
           }
       }
   //-----------------------------
   main	 办理业务
   pool-1-thread-1	 办理业务
   pool-1-thread-4	 办理业务
   pool-1-thread-2	 办理业务
   pool-1-thread-1	 办理业务
   pool-1-thread-5	 办理业务
   pool-1-thread-2	 办理业务
   pool-1-thread-3	 办理业务
   pool-1-thread-4	 办理业务
   ```

   > 使用CallerRunsPolicy, 会将处理不过来的任务回退个调用者(主线程)去执行
   >
   > 后面两种现象市一样的， 但是原理市不一样的

4. 合理的配置线程池你是如何考虑的?

   * CPU密集型

     CPU密集型的意思是该任务需要大量的运算而没有阻塞, CPU一直全速运行.CPU密集型任务只有在真正的多核CPU上才能得到加速.而在单核CPU上无用

     CPU密集型任务配置尽可能配置少的线程数量: :exclamation: **一般是 CPU核心数 + 1**:exclamation: 个线程数的线程池

   * IO密集型

     * 由于IO密集型任务线程并不是一直在执行任务, 则应该配置尽可能多的线程, :exclamation: **CPU核心数 * 2**:exclamation: 

     * IO密集型任务, 即该任务需要大量的IO, 即大量的阻塞.

       在单线程上运行IO密集型任务会导致浪费大量的CPU运算能力在等待上.所以IO密集型任务中使用多线程可以大大的加速程序运行, 即使在单核CPU上, 这种加速主要就是利用了被 浪费掉的阻塞时间

       > IO密集时, 大部分线程都阻塞, 故需要多配置线程数.
       >
       > :exclamation: 参考公式::exclamation: 
       >
       > CPU核心数/(1 - 阻塞系数)    阻塞系数: 0.8 - 0.9
       >
       > 比如8核CPU: 8 / (1 - 0.9) = 80个线程数

### 九.死锁编码以及定位分析

1. 死锁是什么?产生死锁的主要原因

   死锁是指两个或者两个以上的 进程在执行过程总因争夺资源而造成的一种相互等待的额现象, 若无外力干涉, 他们都将无法继续推进下去, 如果系统资源满足, 进程的资源请求都能得到满足, 死锁出现的可能性就很低, 否则就会因为争夺有限的资源而陷入死锁

   <img src="E:\learningNotes\面试专题\pic\image-20201226141355592.png" alt="image-20201226141355592" style="zoom:50%;" />

```java
class HoldLockThread implements Runnable {
    private String lock1;
    private String lock2;

    public HoldLockThread(String lock1, String lock2) {
        this.lock1 = lock1;
        this.lock2 = lock2;
    }

    @Override
    public void run() {
        synchronized (lock1) {
            System.out.println(Thread.currentThread().getName() + "\t 自己持有: " + lock1 + ", 尝试获得:" + lock2);
            try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
            synchronized (lock2) {
                System.out.println(Thread.currentThread().getName() + "\t 自己持有:" + lock1 + ", 尝试获得: " + lock2);
            }
        }

    }
}
public class DeadLoackDemo {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";

        new Thread(new HoldLockThread(lockA, lockB), "AAA").start();
        new Thread(new HoldLockThread(lockB, lockA), "BBB").start();
    }
}
//----------------------------------
BBB	 自己持有: lockB, 尝试获得:lockA
AAA	 自己持有: lockA, 尝试获得:lockB
    ....
```

2. 解决

   * jps ===> java ps 

     找到正在运行的java程序, 定位故java进程号

     ```shell
     PS E:\learningNotes\面试专题\演示代码> jps
     13444 DeadLoackDemo
     10744 Jps
     15016
     12412 Launcher
     ```

   * jstack pid

     打印出某个java进程的堆栈信息(故障报告)

     ```shell
     Java stack information for the threads listed above:
     ===================================================
     "BBB":
             at com.interview.study.thread.HoldLockThread.run(DeadLoackDemo.java:20)
             - waiting to lock <0x00000007169a0148> (a java.lang.String)
             - locked <0x00000007169a0180> (a java.lang.String)
             at java.lang.Thread.run(Thread.java:748)
     "AAA":
             at com.interview.study.thread.HoldLockThread.run(DeadLoackDemo.java:20)
             - waiting to lock <0x00000007169a0180> (a java.lang.String)
             - locked <0x00000007169a0148> (a java.lang.String)
             at java.lang.Thread.run(Thread.java:748)
     
     Found 1 deadlock.
     ```



## JVM+GC专题

### 一.复习

1. JVM内存结构

   * JVM体系概述

     <img src="E:\learningNotes\面试专题\pic\image-20201226144637325.png" alt="image-20201226144637325" style="zoom: 67%;" />

     > * 类加载器
     >
     >   * 启动类加载器
     >   * 根加载器
     >   * 扩展类加载器
     >   * 应用类加载器
     >
     >   考点:
     >
     >   * 类加载器是什么
     >   * 双亲委派机制
     >   * 类加载过程的中的双向安全机制
     >
     > * 图中灰色的部分是线程私有的, 不存在垃圾回收. 图中亮色的两个部分(方法区, 堆)是线程公有的, 存在垃圾回收

   * java8以后的JVM

     <img src="E:\learningNotes\面试专题\pic\image-20201226145116319.png" alt="image-20201226145116319" style="zoom: 67%;" />

     >  jvm8以前打javajava8以后, 永久代改为元空间
     >
     > 元空间和永久代最大的区别在于:
     >
     > 永久代使用的是JVM的堆内存, 元空间并不在虚拟机中而是使用本机的物理内存
     >
     > 因此, 默认情况下, 元空间的大小仅受本地内存限制. 类的元数据放入native memory, 字符串池和类的静态变量放入java堆中, 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制
     >
     > <img src="E:\learningNotes\面试专题\pic\image-20201226162428344.png" alt="image-20201226162428344" style="zoom:67%;" />
     >
     > 方法区是一种规范, 元空间实现了这种规范(元空间就是方法区的具体实现)

2. GC的作用域

   ![image-20201226145258758](E:\learningNotes\面试专题\pic\image-20201226145258758.png)

   线程公有的亮色部分有垃圾回收

3. 常见的垃圾回收算法

   * 引用计数

     <img src="E:\learningNotes\面试专题\pic\image-20201226145759970.png" alt="image-20201226145759970" style="zoom: 67%;" />

     * 缺点:

       * 每次对对象赋值时均要维护引用计数器, 且计数器本身也有一定的消耗

         较处理循环引用

       * 每次对对象赋值时均要维护引用计数器, 且计数器本身也有一定的消耗

         较处理循环引用

     **jvm的实现一般不采用这种方式**:x:

   * 复制(:exclamation: **适用于新生代**:exclamation: )

     <img src="E:\learningNotes\面试专题\pic\image-20201226150039856.png" alt="image-20201226150039856" style="zoom: 67%;" />

   * 标记清除(:exclamation: **适用于老年代**:exclamation: )

     <img src="E:\learningNotes\面试专题\pic\image-20201226150142792.png" alt="image-20201226150142792" style="zoom:67%;" />

     缺点: 内存碎片

   * 标记整理(:exclamation: **适用于老年代**:exclamation: )

     <img src="E:\learningNotes\面试专题\pic\image-20201226150230983.png" alt="image-20201226150230983" style="zoom:67%;" />

     > 分代收集:question:

### 二.题目1

1. JVM垃圾回收的时候如何确定垃圾?是否知道GC Root?

   * 什么是垃圾

     简单来说就是内存中已经不再被使用到的空间就是垃圾

   * 如何判断一个对象是否可以被回收?

     * 引用计数法

       java中引用和对象是有关联的.如果要操作对象, 则必须用引用进行

       因此, 很显然一个简单的方法是通过引用计数法来判断一个对象是否可以被回收. 简单说, 给对象中添加一个引用计数器.每当有一个地方引用它, 计数器值加1;每当有一个引用失效时, 计数器值减1.

       任何时候计数器为0的对象就不再被使用, 那么这个对象就是可回收对象

       那为什么主流的java虚拟机里面灭有选用这种算法呢? 其中最主要的原因就是它很难解决对象之间的循环引用的问题.故而,目前这种算法已经无人使用了

     * 枚举根节点做可达性分析(根搜索路径)

       为了解决引用计数法的循环引用问题, java使用了可达性分析的方法

       <img src="E:\learningNotes\面试专题\pic\image-20201226151908993.png" alt="image-20201226151908993" style="zoom:67%;" />

       > 所谓GC Roots 或者说tracing GC的"根集合" 就是一组必须活跃的引用基本思路就是通过一系列名为"GC Roots"的对象作为起点. 从这个被称为GC Roots的对象开始向下搜索, 如果一个对象到GC Roots没有任何引用链相连时, 则说明此对象不可使用. 也即给定一个集合的引用作为跟触发, 通过引用关系遍历对象图,  能被遍历到的对象就被判定为存活; 没有被遍历到的自然就被判定为死亡.

       <img src="E:\learningNotes\面试专题\pic\image-20201226152447464.png" alt="image-20201226152447464" style="zoom:67%;" />

   * 哪些可以作为GC Roots对象?

     * 虚拟机栈(栈帧中的局部变量区, 叫做局部变量表)中引用的对象
     * 方法区中的类静态属性引用的对象    **static**
     * 方法区中常量引用的对象    **static final**
     * 本地方法栈中JNI(native 方法)引用的对象

2. 你说你做过具名调优和参数配置, 请问如何盘点查看JVM系统默认值?

   * JVM的参数类型

     * 标配参数(了解)

       * -version
       * -help
       * java -showversion

     * x参数(了解)

       * -Xint  解释执行
       * -Xcomp  第一次使用就编译成本地代码
       * -Xmixed  混合模式

     * XX参数(:heavy_check_mark:)

       * Boolean类型

         * 公式

           -XX:+或者-某个属性值(+表示开启, -表示关闭)

         * case

           * 是否打印GC收集细节这个参数

             <img src="E:\learningNotes\面试专题\pic\image-20201226154647669.png" alt="image-20201226154647669" style="zoom:50%;" />

             没有开启

       * KV设值类型

         * 公式: -XX:属性key=属性值value

         * case

           * 查看元空间大小

             <img src="E:\learningNotes\面试专题\pic\image-20201226155029804.png" alt="image-20201226155029804" style="zoom:67%;" />

           

   * 盘点家底查看JVM默认值

     * 公式

       jinfo -flag 配置项 进程编号

     * case1

       <img src="E:\learningNotes\面试专题\pic\image-20201226155534220.png" alt="image-20201226155534220" style="zoom:67%;" />

     * case2

       <img src="E:\learningNotes\面试专题\pic\image-20201226155614821.png" alt="image-20201226155614821" style="zoom:67%;" />

   * 坑题

     **两个经典参数 -Xms 和 -Xmx, 如何理解?**:exclamation::exclamation::exclamation:

     -Xms 等价于-XX:initialHeapSize  初始的堆内存   默认是物理内存的1/64

     -Xmx 等价于-XX:MaxHeapSize  最大堆内存  默认是物理内存的1/4

   * 查看jvm初始参数

     **java -XX:+PrintFlagsInitial**

     <img src="E:\learningNotes\面试专题\pic\image-20201226160500847.png" alt="image-20201226160500847" style="zoom:67%;" />

   * 查看修改/更新的参数

     **java -XX:PrintFlagsFinal**

     <img src="E:\learningNotes\面试专题\pic\image-20201226160634498.png" alt="image-20201226160634498" style="zoom:67%;" />

     如果有 **:=**说明参数被认为的更改过, **=**则表示没有被改过仍然是初始值

   * 查看默认的垃圾回收器

     **java -XX:+PrintCommandLineFlags**

     ![image-20201226161928011](E:\learningNotes\面试专题\pic\image-20201226161928011.png)

3. 你平时工作用过的JVM常用基本配置参数有哪些?

   * -Xms

     初始内存大小, 默认我物理内存的**1/64**, 等价于 **-XX:InitialHeapSize**

   * -Xmx

     最大分配内存, 默认为物理内存的**1/4,** 等价于**-XX:MaxHeapSize**

   * -Xss

     设置单个线程栈的大小, 一般默认为512K ~ 1024K, 等价于 **-XX:ThreadStackSize**

   * -Xmn

     设置年轻代大小

   * -XX:MetaspaceSize

     元空间在本质上和永久代相似, 都是对JVM规范中方法区的实现.不过元空间与永久代的最大区别在于: **元空间并不在虚拟机中, 而是使用本地内存**:heavy_exclamation_mark::heavy_exclamation_mark::heavy_exclamation_mark:. 因此, 默认情况下,元空间的大小仅受本地内存的限制

   * 典型设置案例

     ```shell
     -Xms128m -Xmx4096m -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UserSerialGC
     ```

   * -XX:+PrintGCDetails

     * 在运行java程序时在控制台输出GC收集日志信息

       <img src="E:\learningNotes\面试专题\pic\image-20201226165437194.png" alt="image-20201226165437194" style="zoom:67%;" />

       程序运行结果:

       ![image-20201226170039378](E:\learningNotes\面试专题\pic\image-20201226170039378.png)

       GC收集日志解读:

       <img src="E:\learningNotes\面试专题\pic\image-20201226165653438.png" alt="image-20201226165653438" style="zoom:67%;" />

       FullGC日志解读:

       ![image-20201226170349540](E:\learningNotes\面试专题\pic\image-20201226170349540.png)

       老年代的垃圾回收已经收效甚微, 直接报出OOM

       ![image-20201226170258030](E:\learningNotes\面试专题\pic\image-20201226170258030.png)

   * -XX:SurvivorRatio

     设置新生代中eden和s0/s1空间的比例

     默认-XX:SurvivorRatio=8, Eden:S0:S1=8:1:1

     假如-XX:SurvivorRatio=4, Eden:S0:S1=4:1:1, SurvivorRatio就是设置eden区占新生代的比例, S0/S1相同

   * -XX:NewRatio

     配置年轻代与老年代在堆结构中的占比

     默认

     -XX:NewRatio=2新生代占1, 老年代占2, 年轻代占整个堆内存的1/3

     假如

     -XX:NewRatio=4新生代占1, 老年代占4, 年轻代占整个堆内存的1/5

     NewRatio值就是设置老年代的占比, 剩下的1给新生代

     > -Xmn和-XX:NewRatio同时存在时, 以-Xmn为准

   * -XX:MaxTenuringThreshold

     设置垃圾的最大年龄, 默认是15.如果设置为0, 则表示年轻代对象不经过survivor区, 直接进入老年代. 对于老年代比较多的应用, 可以提高效率. 如果将此值设置为一个较大值, 则年轻代对象会在Survivor区进行多次复制, 这样可以增加对象在年轻代的存活时间, 增加在年轻代回收的概率(降低进入老年代的概率)

4. 强引用, 软引用, 弱引用, 虚引用分别是什么?

   <img src="E:\learningNotes\面试专题\pic\image-20201226182838195.png" alt="image-20201226182838195" style="zoom:67%;" />

   * 强引用

     当内存不足时, JVM开始垃圾回收, 对于强引用的对象, **即使出现了OOM也不会对该对象进行回收**, 死都不收

     强引用是我们最常见的普通对象引用, 只要还有强引用指向一个对象, 就能表明该对象还"活着", 垃圾回收器不会碰这种对象. 在java中最常见的就是强引用, 把一个对象赋值给一个引用变量, 这个引用变量就是一个强引用.当一个对象被强引用时, 它处于可达状态, 它是不可能被垃圾回收机制回收的, 即使该对象以后永远都不会被用到JVM也不会回收. 因此强引用是造成java内存泄露的主要原因之一

     对于一个普通的对象， 如果没有其他的引用关系， 只要超过了引用的作用域或者显示的将相应（强）引用赋值为null， 一般认为就是可以被垃圾回收了

     ```java 
     public class StrongReferenceDemo {
         public static void main(String[] args) {
             Object o1 = new Object();
             Object o2 = o1;
             o1 = null;
             System.gc();
             System.out.println(o2);
         }
     }
     ```

   * 软引用

     软引用是一种相对强引用弱化了一些的引用, 需要用java.lang.ref.SoftReference类来实现, 可以让对象豁免一些垃圾收集

     对于只有软引用的对象来说:

     * 当系统内存充足时, 它不会被回收

       ```java
       public static void softref_Memory_Enough() {
               Object o1 = new Object();
               java.lang.ref.SoftReference<Object> softReference = new java.lang.ref.SoftReference<>(o1);
               System.out.println(o1);
               System.out.println(softReference.get());
       
               o1 = null;
               System.gc();
       
               System.out.println(o1);
               System.out.println(softReference.get());
           }
       //-------------------------
       java.lang.Object@1540e19d
       java.lang.Object@1540e19d
       null
       java.lang.Object@1540e19d
       ```

     * 当系统内存不足时, 它会被回收

       将堆的大小设置为10m, 定义一个30m的字节数组, 模拟内存不足的情况

       ```java
       public static void softref_Memory_NotEnough() {
           Object o1 = new Object();
           java.lang.ref.SoftReference<Object> softReference = new java.lang.ref.SoftReference<>(o1);
           System.out.println(o1);
           System.out.println(softReference.get());
       
           o1 = null;
       
       
           try {
               byte[] bytes = new byte[30 * 1024 * 1024];
           }catch(Throwable e) {
               e.printStackTrace();
           } finally {
               System.out.println(o1);
               System.out.println(softReference.get());
           }
       }
       //----------------------
       java.lang.Object@1540e19d
       java.lang.Object@1540e19d
       null
       null
       java.lang.OutOfMemoryError: Java heap space
       	at com.interview.study.jvm.SoftReference.softref_Memory_NotEnough(SoftReference.java:31)
       	at com.interview.study.jvm.SoftReference.main(SoftReference.java:6)
       ```

       > 应用场景:
       >
       > 假如有一个应用需要读取大量本地图片:
       >
       > * 如果每次读取图片都要从硬盘读取会严重影响性能
       > * 如果一次性全部加载到内存中有可能造成内存溢出
       >
       > 此时使用软引用解决:
       >
       > 用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系, 当内存不足时, JVM会自动回收这些缓存图片对象所占用的空间, 从而有效的避免了OOM的问题
       >
       > ![image-20201226190942551](E:\learningNotes\面试专题\pic\image-20201226190942551.png)

   * 弱引用

     弱引用需要用**java.lang.ref.WeakReference**类来实现, 它比软引用的生存期更短

     对于只有弱引用的对象来说, 只要垃圾回收机制一运行, 不管JVM的内存空间是否充足, 都会回收该对象占用的空间

     ```java
     public static void main(String[] args) {
             Object o1 = new Object();
             WeakReference<Object> weakReference = new WeakReference<>(o1);
     
             System.out.println(o1);
             System.out.println(weakReference.get());
     
             o1 = null;
             
             System.gc();
     
             System.out.println(o1);
             System.out.println(weakReference.get());
         }
     //--------------------------
     java.lang.Object@1540e19d
     java.lang.Object@1540e19d
     null
     null
     ```

     **你知道WeakHashMap吗?**

     ```java
     public class WeakHashMapDemo {
         public static void main(String[] args) {
             myHashMap();
             System.out.println("=======================");
             myWeakHashMap();
         }
     
         private static void myHashMap() {
             HashMap<Integer, String> map = new HashMap<>();
             Integer key = new Integer(1);
             String value = "hashmap";
     
             map.put(key, value);
             System.out.println(map);
     
             key = null;
             System.out.println(map);
     
             System.gc();
             System.out.println(map);
         }
     
         private static void myWeakHashMap() {
             WeakHashMap<Integer, String> map = new WeakHashMap<>();
             Integer key = new Integer(2);
             String value = "weakhashmap";
     
             map.put(key, value);
             System.out.println(map);
     
             key = null;
             System.out.println(map);
     
             System.gc();
             System.out.println(map);
         }
     }
     //---------------------
     {1=hashmap}
     {1=hashmap}
     {1=hashmap}
     =======================
     {2=weakhashmap}
     {2=weakhashmap}
     {}
     ```

   * 虚引用

     虚引用需要java.lang.PhantomReference类来实现

     虚引用, 形同虚设, 虚引用并不会决定对象的生命周期

     **如果一个对象仅仅持有虚引用, 那么它就和没有任何引用一样, 在任何时候都可能被垃圾回收器回收, 它不能单独使用也不能通过它访问对象, 虚引用必须和引用队列联合使用**

     **虚引用的主要作用是跟踪对象被垃圾回收的状态.** 仅仅是提供了一种确保独享被finalize以后, 做某些事情的机制.

     PhantomReference的get方法总是返回null, 因此无法访问对应的引用对象, 其意义在于说明一个对象已经进入了finalization阶段, 可以被gc回收, 用来实现比funalization机制更加灵活的回收机制

     换句话说, 设置虚引用关联度额唯一目的, 就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理.java技术允许使用finalize方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作.

     ```java
     public static void main(String[] args) {
             Object o1 = new Object();
             ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
             WeakReference<Object> weakReference = new WeakReference<>(o1, referenceQueue);
     
             System.out.println(o1);
             System.out.println(weakReference.get());
             System.out.println(referenceQueue.poll());
     
             System.out.println("=======================");
             o1 = null;
             System.gc();
             System.out.println(o1);
             System.out.println(weakReference.get());
             System.out.println(referenceQueue.poll());
         }
     //------------------------------
     java.lang.Object@1540e19d
     java.lang.Object@1540e19d
     null
     =======================
     null
     null
     java.lang.ref.WeakReference@677327b6
     ```

     > 弱引用对象在被回收前会被放到引用队列中

     ```java
     public static void main(String[] args) {
             Object o1 = new Object();
             ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
             PhantomReference<Object> weakReference = new PhantomReference<>(o1, referenceQueue);
     
             System.out.println(o1);
             System.out.println(weakReference.get());
             System.out.println(referenceQueue.poll());
     
             System.out.println("=======================");
             o1 = null;
             System.gc();
             System.out.println(o1);
             System.out.println(weakReference.get());
             System.out.println(referenceQueue.poll());
         }
     //---------------------------
     java.lang.Object@1540e19d
     null
     null
     =======================
     null
     null
     java.lang.ref.PhantomReference@677327b6
     ```

     > 创建引用的时候可以指定关联的队列, 当工程释放对象内存时, 会将引用加入到引用队列, 如果程序发现某个虚引用已经被加入到引用队列, 那么就可以在锁引用的对象的内存被回收之前采取必须要的行动, 这相当于是一种通知机制.
     >
     > 当关联的引用队列中有数据的时候, 意味着引用指向的堆内存中的对象被回收.通过这种方式, JVM允许我们在对象被销毁后做一些我们自己想做的事情

   * 小总结

     <img src="E:\learningNotes\面试专题\pic\image-20201226195047322.png" alt="image-20201226195047322" style="zoom: 33%;" />

5. 请谈谈你对OOM的认识?

   * java.lang.StackOverflowError

     方法的递归调用而没有设置递归出口

     ```java
     public class StackOverflowErrorDemo {
         public static void main(String[] args) {
             stackOverFlowError();
         }
     
         private static void stackOverFlowError() {
             stackOverFlowError();
         }
     }
     //------------------
     Exception in thread "main" java.lang.StackOverflowError
     	at com.interview.study.jvm.StackOverflowErrorDemo.stackOverFlowError(StackOverflowErrorDemo.java:9)
     	at com.interview.study.jvm.StackOverflowErrorDemo.stackOverFlowError(StackOverflowErrorDemo.java:9)
     	at com.interview.study.jvm.StackOverflowErrorDemo.stackOverFlowError(StackOverflowErrorDemo.java:9)
     	at com.interview.study.jvm.StackOverflowErrorDemo.stackOverFlowError(StackOverflowErrorDemo.java:9)
     	at com.interview.study.jvm.StackOverflowErrorDemo.stackOverFlowError(StackOverflowErrorDemo.java:9)
     ```

   * java.lang.OutOfMemoryError:java heap space

     不断的产生新的对象(强引用对象不会被回收)

     ```java
     public static void main(String[] args) {
             String str = "heapSpace";
     
             while (true) {
                 str += str + new Random().nextInt(111111111) + new Random().nextInt(222222);
             }
         }
     //-------------------------------------------
     Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
     	at java.util.Arrays.copyOf(Arrays.java:3332)
     	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)
     	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674)
     	at java.lang.StringBuilder.append(StringBuilder.java:208)
     	at com.interview.study.jvm.JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:10)
     ```

     

   * java.lang.OutOfMemoryError:GC overhead limit exceeded

     GC回收时间过长. 超过98%的时间用来做GC并且回收了不到2%的堆内存, 连续多次GC, 都回收了不到2%内存的极端情况下才会抛出. 假如不抛出GC overhead limit 错误会发生什么情况呢?

     那就是GC清理的那么点内存很快会被再次填满, 迫使GC再次执行, 这样就形成了恶性循环.CPU使用率一直是100%, 但是GC没有任何效果

     <img src="E:\learningNotes\面试专题\pic\image-20201227104540610.png" alt="image-20201227104540610" style="zoom:67%;" />

     ```java
     public static void main(String[] args) {
             int i = 0;
             List<String> list = new ArrayList<>();
     
             try {
                 while (true) {
                     list.add(String.valueOf(++i));
                 }
             } catch (Throwable e) {
                 System.out.println("*******************i: " + i);
                 e.printStackTrace();
                 throw e;
             }
         }
     //-------------------------------------
     [GC (Allocation Failure) [PSYoungGen: 2048K->496K(2560K)] 2048K->824K(9728K), 0.0008755 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
     [GC (Allocation Failure) [PSYoungGen: 2490K->507K(2560K)] 2818K->2499K(9728K), 0.0018244 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
     [GC (Allocation Failure) [PSYoungGen: 2555K->496K(2560K)] 4547K->4254K(9728K), 0.0015559 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
     [GC (Allocation Failure) [PSYoungGen: 2544K->512K(2560K)] 6302K->6334K(9728K), 0.0018859 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 512K->0K(2560K)] [ParOldGen: 5822K->5887K(7168K)] 6334K->5887K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0339206 secs] [Times: user=0.19 sys=0.00, real=0.04 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2048K->422K(2560K)] [ParOldGen: 5887K->7054K(7168K)] 7935K->7476K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0254941 secs] [Times: user=0.17 sys=0.00, real=0.03 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2048K->2047K(2560K)] [ParOldGen: 7054K->7054K(7168K)] 9102K->9102K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0187027 secs] [Times: user=0.05 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2048K->2047K(2560K)] [ParOldGen: 7054K->7054K(7168K)] 9102K->9102K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0155957 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7054K->7054K(7168K)] 9102K->9102K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0162097 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7056K->7056K(7168K)] 9104K->9104K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0156381 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7058K->7058K(7168K)] 9106K->9106K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153363 secs] [Times: user=0.09 sys=0.02, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7060K->7060K(7168K)] 9108K->9108K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0159949 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7061K->7061K(7168K)] 9109K->9109K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0154558 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7063K->7063K(7168K)] 9111K->9111K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0154618 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7065K->7065K(7168K)] 9113K->9113K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0157235 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7067K->7067K(7168K)] 9115K->9115K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153286 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7068K->7068K(7168K)] 9116K->9116K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153650 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7070K->7070K(7168K)] 9118K->9118K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153122 secs] [Times: user=0.09 sys=0.02, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7072K->7072K(7168K)] 9120K->9120K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153498 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7074K->7074K(7168K)] 9122K->9122K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153348 secs] [Times: user=0.08 sys=0.00, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7075K->7075K(7168K)] 9123K->9123K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153575 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7077K->7077K(7168K)] 9125K->9125K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0167267 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7079K->7079K(7168K)] 9127K->9127K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0157206 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7081K->7081K(7168K)] 9129K->9129K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153760 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7082K->7082K(7168K)] 9130K->9130K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0154962 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7084K->7084K(7168K)] 9132K->9132K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0155376 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7086K->7086K(7168K)] 9134K->9134K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0156835 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7088K->7088K(7168K)] 9136K->9136K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0156029 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7089K->7089K(7168K)] 9137K->9137K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153864 secs] [Times: user=0.08 sys=0.02, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7091K->7091K(7168K)] 9139K->9139K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0157723 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7093K->7093K(7168K)] 9141K->9141K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0155182 secs] [Times: user=0.09 sys=0.00, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7095K->7095K(7168K)] 9143K->9143K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0158057 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7096K->7096K(7168K)] 9144K->9144K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0153804 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7098K->7098K(7168K)] 9146K->9146K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0154037 secs] [Times: user=0.06 sys=0.02, real=0.01 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7100K->7100K(7168K)] 9148K->9148K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0154287 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7102K->7102K(7168K)] 9150K->9150K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0154817 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7103K->7103K(7168K)] 9151K->9151K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0155252 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7105K->7105K(7168K)] 9153K->9153K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0157868 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7107K->7107K(7168K)] 9155K->9155K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0155022 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7109K->7109K(7168K)] 9157K->9157K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0155351 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7110K->7110K(7168K)] 9158K->9158K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0160152 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7112K->7112K(7168K)] 9160K->9160K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0166871 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7114K->7114K(7168K)] 9162K->9162K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0163161 secs] [Times: user=0.19 sys=0.01, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7116K->7116K(7168K)] 9164K->9164K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0156625 secs] [Times: user=0.09 sys=0.02, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7117K->7117K(7168K)] 9165K->9165K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0160708 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7119K->7119K(7168K)] 9167K->9167K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0158278 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
     [Full GC (Ergonomics) [PSYoungGen: 2047K->2047K(2560K)] [ParOldGen: 7121K->7102K(7168K)] 9169K->9150K(9728K), [Metaspace: 3499K->3499K(1056768K)], 0.0268088 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] 
     *******************i: 145502
     [Full GC (Ergonomics) [PSYoungGen: 2047K->0K(2560K)] [ParOldGen: 7119K->648K(7168K)] 9167K->648K(9728K), [Metaspace: 3525K->3525K(1056768K)], 0.0032158 secs] [Times: user=0.08 sys=0.03, real=0.00 secs] 
     Heap
      PSYoungGen      total 2560K, used 57K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
       eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0e570,0x00000000fff00000)
       from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
       to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
      ParOldGen       total 7168K, used 648K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
       object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a2048,0x00000000ffd00000)
      Metaspace       used 3533K, capacity 4506K, committed 4864K, reserved 1056768K
       class space    used 391K, capacity 394K, committed 512K, reserved 1048576K
     java.lang.OutOfMemoryError: GC overhead limit exceeded
     	at java.lang.Integer.toString(Integer.java:401)
     	at java.lang.String.valueOf(String.java:3099)
     	at com.interview.study.jvm.GCOverHeadDemo.main(GCOverHeadDemo.java:13)
     Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
     	at java.lang.Integer.toString(Integer.java:401)
     	at java.lang.String.valueOf(String.java:3099)
     	at com.interview.study.jvm.GCOverHeadDemo.main(GCOverHeadDemo.java:13)
     
     ```

     ```shell
     -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m
     ```

   * java.lang.OutOfMemoryError:Direct buffer memory

     元空间的本质与永久代类似, 都是对JVM规范找那个方法区的实现. 不过元空间与永久代之间最大的区别在于元空间并不在虚拟机中, 而是使用本地内存. 因此默认情况下, 元空间的大小受本地内存限制

     **导致原因:**

     > 写NIO程序的时候经常使用ByteBuffer来读取或者写入数据, 这是一种基于通道(Channel)与缓冲区(Buffer)的IO方式, 他可以使用Native函数库直接分配堆外内存, 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作. 这样能再一些场景中显著提高性能, 因为避免了在Java堆中和Native堆中来回复制数据
     >
     > ByteBuffer.allocate(capacity) 第一种方式是分配JVM内存, 属于GC管辖范畴, 由于需要拷贝, 一次速度相对较慢
     >
     > ByteBuffer.allocateDirect(capacity): 第二种方式是分配OS本地内存, 不属于GC管辖范畴, 由于不需要内存拷贝, 所以速度型相对较快
     >
     > 但是如果不断的分配本地内存, 堆内存很少使用, 那么JVM就需要执行GC, DirectByteBuffer对象们就不会被回收, 这个时候堆内存充足, 但是本地内存可能已经用光了, 再次尝试分配本地内存就会出现OOM

     ```java
     public static void main(String[] args) {
             System.out.println("配置的最大直接内存: " + sun.misc.VM.maxDirectMemory() / (double)1024 / 1024 + "MB");
     
             try {
                 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
             } catch (Exception e) {
                 e.printStackTrace();
             }
     
             ByteBuffer bb = ByteBuffer.allocateDirect(6 * 1024 * 1024);
         }
     //-----------------------------
     配置的最大直接内存: 5.0MB
     [GC (Allocation Failure) [PSYoungGen: 2048K->488K(2560K)] 2048K->732K(9728K), 0.0009129 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
     [GC (System.gc()) [PSYoungGen: 1535K->504K(2560K)] 1779K->1120K(9728K), 0.0029021 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
     [Full GC (System.gc()) [PSYoungGen: 504K->0K(2560K)] [ParOldGen: 616K->1036K(7168K)] 1120K->1036K(9728K), [Metaspace: 4042K->4042K(1056768K)], 0.0199098 secs] [Times: user=0.13 sys=0.00, real=0.02 secs] 
     Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
     	at java.nio.Bits.reserveMemory(Bits.java:693)
     	at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)
     	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)
     	at com.interview.study.jvm.DirectBufferMemoryDemo.main(DirectBufferMemoryDemo.java:16)
     Heap
      PSYoungGen      total 2560K, used 79K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
       eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd13e60,0x00000000fff00000)
       from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
       to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
      ParOldGen       total 7168K, used 1036K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
       object space 7168K, 14% used [0x00000000ff600000,0x00000000ff7032f8,0x00000000ffd00000)
      Metaspace       used 4074K, capacity 4568K, committed 4864K, reserved 1056768K
       class space    used 456K, capacity 460K, committed 512K, reserved 1048576K
     ```

     ```shell
     -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m
     ```

   * java.lang.OutOfMemoryError:unable to create new native thread

     不能再创建本地线程了(高并发场景会报出)

     **导致原因:**

     > 你的应用程序创建了太多的线程, 一个应用程序创建多个线程, 超过了系统承载极限
     >
     > 你的服务器不允许你的应用程序创建这么多的线程, Linux系统默认允许单个进程可以创建的线程数为1024个, 你的应用创建超过这个数量, 就会报这个异常

     **解决方法:**

     > 想办法降低你的应用程序创建的线程的数量, 分析应用是否真的需要创建这么多线程, 如果不是, 将线程数量降到最低
     >
     > 对于有的应用, 确实需要创建很多线程, 远远超过Linux的限制, 可以通过修改Linux服务器的配置, 扩大默认限制

     ```java
     public static void main(String[] args) {
             for (int i = 1; ; i++) {
                 System.out.println("****************i:" + i);
     
                 new Thread(() -> {
                     try { TimeUnit.SECONDS.sleep(Integer.MAX_VALUE); } catch (InterruptedException e) { e.printStackTrace(); }
                 }, String.valueOf(i)).start();
             }
         }
     //-----------------------
     ****************i:236999
     Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread
     	at java.lang.Thread.start0(Native Method)
     	at java.lang.Thread.start(Thread.java:717)
     	at com.interview.study.jvm.UnableCreateThreadDemo.main(UnableCreateThreadDemo.java:12)
     ```

   * java.lang.OutOfMemoryError:Metaspace

     <img src="E:\learningNotes\面试专题\pic\image-20201227113839825.png" alt="image-20201227113839825" style="zoom:67%;" />

     ```shell
     PS C:\Windows> java -XX:+PrintFlagsInitial
     ```

     <img src="E:\learningNotes\面试专题\pic\image-20201227114035005.png" alt="image-20201227114035005" style="zoom:67%;" />

     ```shell
     -XX:MetaspaceSize=8m  -XX:MaxMetaspaceSize=8m 
     ```

     > metaspace是方法区在HotSpot中的实现, 他与永久代最大的区别在于:MetaSpace并不在虚拟机内存中而是使用本地内存, 也即在java8中, classe metadata (the virtual internal presentation of java class), 被存储在叫做Metaspace的native memory
     >
     > 永久代被取代后存放了一下信息:
     >
     > * 虚拟机加载的类信息
     > * 常量池
     > * 静态变量
     > * 即时编译后的代码
     >
     > 模拟MetaSpace空间溢出, 我们不断生成静态类往元空间中加, 类占据的空间总是会超过元空间的大小

     <img src="E:\learningNotes\面试专题\pic\image-20201227114950037.png" alt="image-20201227114950037" style="zoom:67%;" />

     **需要引入cglib的依赖**

     <img src="E:\learningNotes\面试专题\pic\image-20201227115027234.png" alt="image-20201227115027234" style="zoom:67%;" />

6. GC垃圾回收算法和垃圾收集器的关系?分别是什么请你谈谈?

   GC算法(引用计数/复制/标记清除/标记整理)是内存回收的方法论, 垃圾收集器就是算法落地实现.因为目前还灭有完美的垃圾收集器出现, 更加没有万能的垃圾收集器, 只是针对具体的应用采用最合适的收集器, 进行分代垃圾回收

   <img src="E:\learningNotes\面试专题\pic\image-20210110142545318.png" alt="image-20210110142545318" style="zoom:50%;" />

   1. 垃圾回收器

      * 串行垃圾回收器(serial)

        它为单线程环境设计且只使用一个线程进行垃圾回收, 会暂停所有的用户线程, 所以不适合服务器环境.

      * 并行垃圾回收器(Parallel)

        多个垃圾收集器并行工作, 此时用户线程是暂停的, 适用于科学计算/大数据处理首台处理等弱交互场景

      * 并发垃圾回收器(CMS)

        用户线程和垃圾收集线程同时执行(不一定并行, 可能交替执行), 不需要停顿用户线程, 适用于对响应时间有要求的场景.

      * G1垃圾回收器

        Java8以后使用的是这个

        G1垃圾回收器将堆内存分隔成不同的区域然后并发的对其进行垃圾回收

   2. 总计

      <img src="E:\learningNotes\面试专题\pic\image-20210110143617830.png" alt="image-20210110143617830" style="zoom:50%;" />

7. 怎么查看服务器默认的垃圾收集器是哪个?生产商如何配置垃圾收集器?谈谈你对垃圾收集器的理解?

   * 如何查看服务器默认的垃圾收集器是哪个

      -XX:+PrintCommandLineFlags

   * java的gc回收的类型主要有以下几种(6种)

     * UseSerialGC
     * UseParallelGC
     * UseConcMarkSweepGC
     * UseParNewGC
     * UseParallelOldGC
     * UseG1GC

   * 垃圾回收器使用

     <img src="E:\learningNotes\面试专题\pic\image-20210110145159428.png" alt="image-20210110145159428" style="zoom:50%;" />

     <img src="E:\learningNotes\面试专题\pic\image-20210110145407122.png" alt="image-20210110145407122" style="zoom:50%;" />

     > young区多使用复制算法, old区多使用标记清除和标记整理算法

   * 垃圾收集器

     * 部分参数预先说明

       * DefNew    Default New Generation 默认在新生代使用
       * Tenured    Old
       * ParNew      Parallel New Generation
       * PSYoungGen    Parallel Scavenge
       * ParOldGen    Parallel Old Generation

     * Server/Client模式分别是什么意思

       jvm虚拟机根据电脑配置的不同, 自行决定是Server模式还是Client模式

     * 新生代

       * 串行(Serial)/(Serial Copying)

         一个单线程的垃圾收集器, 在进行垃圾收集的时候, 必须暂停其他所有的工作线程, 直到收集结束

         <img src="E:\learningNotes\面试专题\pic\image-20210110150634208.png" alt="image-20210110150634208" style="zoom: 67%;" />

         串行收集器是最古老最稳定效率最高的垃圾收集器, 只使用一个线程去回收但是在其进行垃圾回收的过程中可能会产生较长的停顿.虽然在收集垃圾的过程中需要暂停所有其他的工作线程, 但是简单高效, 对于限定单个CPU环境来说, 没有线程切换的开销可以获得最高的单线程垃圾收集效率, 因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器

         <img src="E:\learningNotes\面试专题\pic\image-20210110151039723.png" alt="image-20210110151039723" style="zoom: 67%;" />

       * 并行GC(ParaNew)

         使用多线程进行垃圾回收, 在垃圾收集时, 会STW暂停其他所有的工作线程直达收集结束

         <img src="E:\learningNotes\面试专题\pic\image-20210110151402236.png" alt="image-20210110151402236" style="zoom:67%;" />

         ParNew收集器其实就是Serial收集器新生代的并行多线程版本, 最常见的应用场景是配合老年代的CMC GC工作, 其余的行为和Serial收集器完全一致, ParNew垃圾收集器过程中同样也要暂停其他所有的工作线程, 他是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器.

         <img src="E:\learningNotes\面试专题\pic\image-20210110151754156.png" alt="image-20210110151754156" style="zoom:67%;" />

       * 并行回收GC(Parallel)/(Parallel Scavenge)

         <img src="E:\learningNotes\面试专题\pic\image-20210110153610488.png" alt="image-20210110153610488" style="zoom: 80%;" />

         类似ParNew, 也是一个新生代垃圾收集器, 使用复制算法, 也是一个并行的多线程的垃圾收集器, 俗称吞吐量优先收集器. 串行收集器在新生代和老年代的并行化

         <img src="E:\learningNotes\面试专题\pic\image-20210110153816487.png" alt="image-20210110153816487" style="zoom:67%;" />

     * 老年代

       * 串行GC(Serial Old)/(Serial MSC)

         Serial Old是Serial垃圾收集器的老年代版本, 他同样是单线程的收集器, 这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器

         在Server模式下, 主要有两个用途:

         1. 在JDK1.5之前的版本中与新生代的Parallel Scavenge 收集器配合使用
         2. 作为老年代版中使用CMS收集器的后备垃圾回收方案

       * 并行GC(Parallel Old)/(Parallel MSC)

         Parallel Old收集器是Parallel Scavenge的老年代版本, 使用多线程的标记-整理算法, Parallel Old收集器在JDK 1.6才开始提供.在这之前, 新生代使用Parallel Scavenge收集器只能搭配老年代的Serial Old收集器, 只能保证新生代的吞吐量优先, 无法保证整体的吞吐量.Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器, 如果系统对吞吐量要求较高, JDK8之后可以优先考虑新生代Parallel Scavenge和老年代的Parallel Old收集器的搭配

       * 并发标记清除GC(CMS)

         CMS收集器(Concurrent Mark Sweep: 并发标记清除)是一种以获取最短停顿时间为目标的收集器.适合应用在互联网或者B/S系统的服务器, 这类应用尤其重视服务器的响应速度, 系统系统停顿时间最短.CMS非常适合堆内存大, CPU核数都的服务器应用, 是G1出现之前大型应用的首选垃圾收集器

         <img src="E:\learningNotes\面试专题\pic\image-20210110155239205.png" alt="image-20210110155239205" style="zoom: 80%;" />

         ![image-20210110155547111](E:\learningNotes\面试专题\pic\image-20210110155547111.png)

         步骤:

         * 初始标记  只是标记一下GC Root能直接关联的对象, 速度很快, 仍然需要暂停所有的工作线程

         * 并发标记 和用户线程一起, 不用暂停用户线程.进行GC Roots跟踪的过程, 和用户线程一起工作, 不需要暂停工作线程. 主要标记过程, 标记全部对象

         * 重新标记 为了修正在并发标记期间, 因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 仍然需要暂停所有的工作对象.由于并发标记时, 用户线程依然运行, 因此在正式清理前再做修正

         * 并发清除

           清除GC Root不可达对象, 和用户线程一起工作, 需要暂停工作线程. 基于标记结果, 直接清理对象. 由于耗时最长的并发标记和并发清除过程中, 垃圾收集线程可以和用户在一起并发工作, 所以总体上来看CMS收集器的内存回收和用户线程是一起并发的执行

           > 由于并发进行, CMS在收集与应用线程会同时增加对堆内存的占用, 也就是说, CMS必须要在老年代堆内存用尽之前完成垃圾回收, 否则CMS回收失败时, 将处罚担保机制, 串行老年代收集器将会以STW的方式进行一次GC, 从而造成较大停顿

           * 优点:

             并发收集低停顿

           * 缺点:

             并发执行, 对CPU资源压力大

             采用的标记清除算法会导致大量的碎片

     * 垃圾收集器配置代码总结

       <img src="E:\learningNotes\面试专题\pic\image-20210110173238472.png" alt="image-20210110173238472" style="zoom:67%;" />

8. G1垃圾收集器

   * 以前的垃圾收集器的特点

     * 老年代G1是什么和新生代是各自独立且连续的内存块
     * 年轻代收集使用单eden+S0+S1机型复制算法
     * 老年代收集必须扫描整个老年代区域
     * 都是以尽可能少儿快速的执行GC为原则

   * G1是什么

     G1垃圾收集器, 是一款面向服务端应用的收集器, 应用在多处理器和大容量内存环境中, 在实现高吞吐量的同时, 尽量可能的满足垃圾收集暂停时间的要求, 还具备以下特点:

     * 像CMS一样, 能与应用程序并发执行
     * 整理空闲空间更快
     * 需要更多的时间来预测GC停顿时间
     * 不希望牺牲大量的吞吐性能
     * 不需要更大的Java Heap

     ![image-20210110174724151](E:\learningNotes\面试专题\pic\image-20210110174724151.png)

     ![image-20210110174229093](E:\learningNotes\面试专题\pic\image-20210110174229093.png)

   * 底层原理

     * region 区域化垃圾收集器
     * 回收步骤
     * 4步过程

   * case案例

   * 常用配置参数

   * 和CMS相比的优势

   * 小总结

9. 生产环境服务器变慢, 诊断思路和性能评估谈谈?

10. 假如生产环境出现CPU占用过高, 请谈谈你的分析思路和定位?

### 三.题目2

### 四.其他



## java基础

### java字符串常量池

1. intern方法

   ![image-20210116124532374](E:\learningNotes\面试专题\pic\image-20210116124532374.png)

   ![image-20210116124745463](E:\learningNotes\面试专题\pic\image-20210116124745463.png)

   > true / false
   >
   > 按照代码结果来看, java字符串的答案为false, 必然是两个不同的java, 那另一个java字符串如何加载进来的?
   >
   > 有一个初始化的java字符串, 在加载sun.misc.Version这个类的时候进入常量池的
   >
   > ![image-20210116125218655](E:\learningNotes\面试专题\pic\image-20210116125218655.png)

2. 算法题 - 两数之和

   ![image-20210116131535484](E:\learningNotes\面试专题\pic\image-20210116131535484.png)

### LRU算法

### redis



## JUC

### 可重入锁(又名递归锁)

是指在同一个线程在外层方法获取锁的时候, 再进入该线程的内层方法会自动获取锁(前提, 锁对象是同一个对象), 不会因为之前已经获取过还没释放而阻塞

> java中的ReentrantLock和Syncchronized都是可重入锁, 可重入锁可以有效避免死锁

1. 可重入锁的种类

   隐式锁(即使用synchronized关键字使用的锁)默认是可重入锁

   * 同步块

     ```java
     public class ReEnterLockDemo {
         public static Object objectLockA = new Object();
         public  static void m1() {
             synchronized (objectLockA) {
                 System.out.println("外层调用");
                 synchronized (objectLockA) {
                     System.out.println("中层调用");
                     synchronized (objectLockA) {
                         System.out.println("内层调用");
                     }
                 }
             }
         }
         public static void main(String[] args) {
             m1();
         }
     }
     ```

   * 同步方法

     ```java
     public static void main(String[] args) {
         //m1();
         new ReEnterLockDemo().m2();
     }
     
     public  synchronized void m2(){
         System.out.println("外层调用");
         m3();
     }
     
     public  synchronized void m3(){
         System.out.println("中层调用");
         m4();
     }
     public  synchronized void m4(){
         System.out.println("内层调用");
     }
     ```

2. synchronized的重入的实现原理

   ![image-20210116134200363](E:\learningNotes\面试专题\pic\image-20210116134200363.png)

3. 显示锁也有ReentrantLock这样的可重入锁

   Lock lock = new ReentrantLock();

   lock.lock();

   ....

   lock.unlock();

### LockSupport

1. 线程等待唤醒机制(wait/notify)

   LockSupport是用来创建锁和其他同步类的基本线程阻塞原语

   LockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程

   * 三种让线程等待和唤醒的方法

     ![image-20210116135716330](E:\learningNotes\面试专题\pic\image-20210116135716330.png)

     > 

     * Object类中的wait和notify方法实现线程等待和唤醒
     * Condition接口中的await和signal方法实现线程的等待和唤醒
     * LockSupport类中的park等待和unpark唤醒

   * Object类中的wait和notify方法实现线程等待和唤醒

     ![image-20210116140020949](E:\learningNotes\面试专题\pic\image-20210116140020949.png)

     > 必须先wait后notify, 否则等待的线程无法被唤醒.而且这两种方法不能脱离synchronized使用, 否则会有异常
     >
     > ![image-20210116140144162](E:\learningNotes\面试专题\pic\image-20210116140144162.png)

   * Condition接口中的await和signal方法实现线程的等待和唤醒

     ![image-20210116140540387](E:\learningNotes\面试专题\pic\image-20210116140540387.png)

     ![image-20210116140611327](E:\learningNotes\面试专题\pic\image-20210116140611327.png)

     > 必须和lock 和unlock联合使用, 否则会报错
     >
     > ![image-20210116140803387](E:\learningNotes\面试专题\pic\image-20210116140803387.png)
     >
     > 必须先await后notify

   * 传统的synchronized的Lock实现等待唤醒通知的约束

   * LockSupport类中的park等待和unpark唤醒

     ![image-20210116141004620](E:\learningNotes\面试专题\pic\image-20210116141004620.png)

     ![image-20210116141049339](E:\learningNotes\面试专题\pic\image-20210116141049339.png)

     ![image-20210116141251333](E:\learningNotes\面试专题\pic\image-20210116141251333.png)

     > unpark可以在park之前执行
     >
     > 不需要配合锁块使用
     >
     > 重要说明
     >
     > ![image-20210116141528168](E:\learningNotes\面试专题\pic\image-20210116141528168.png)
     >
     > ![image-20210116141642115](E:\learningNotes\面试专题\pic\image-20210116141642115.png)
     >
     > ![image-20210116141733002](E:\learningNotes\面试专题\pic\image-20210116141733002.png)

### AQS

抽象的队列同步器

1.  AQS是什么

![image-20210116144114382](E:\learningNotes\面试专题\pic\image-20210116144114382.png)

![image-20210116144246052](E:\learningNotes\面试专题\pic\image-20210116144246052.png)

2. AQS能干什么

   ![image-20210116145020847](E:\learningNotes\面试专题\pic\image-20210116145020847.png)

   和AQS有关的

   * ReentrantLock

   * CountDownLatch

   * ReentrantReadWriteLock

   * Semaphore

     ...

   ![image-20210116145241958](E:\learningNotes\面试专题\pic\image-20210116145241958.png)

3. AQS内部体系结构

   ![image-20210116145904354](E:\learningNotes\面试专题\pic\image-20210116145904354.png)

   * AQS自身

     * AQS的int变量

       AQS的同步状态State成员变量.0可以占用, 1 需要等待

     * AQS的CLH队列

       双向队列

     * 小总结

       有阻塞就需要排队, 实现队列必然需要队列

       state变量+CLH变种的双端队列

   * 内部类Node

     * node的int变量

       waitstatus

       ![image-20210116150850463](E:\learningNotes\面试专题\pic\image-20210116150850463.png)

4. AQS同步队列的基本结构

   ![image-20210116150919187](E:\learningNotes\面试专题\pic\image-20210116150919187.png)



5. 源码解读AQS

   Lock接口的实现类基本上都是通过聚合了一个队列同步器的子类完成线程访问控制的

   * ReentrantLock的原理

   * 从最简单的lock方法开始看公平锁和非公平锁

     ![image-20210116151752484](E:\learningNotes\面试专题\pic\image-20210116151752484.png)

     ![image-20210116151817726](E:\learningNotes\面试专题\pic\image-20210116151817726.png)

     ![image-20210116151919315](E:\learningNotes\面试专题\pic\image-20210116151919315.png)

     ![image-20210116152056891](E:\learningNotes\面试专题\pic\image-20210116152056891.png)

     ![image-20210116152128182](E:\learningNotes\面试专题\pic\image-20210116152128182.png)

   * 非公平锁, lock

     ![image-20210116153028378](E:\learningNotes\面试专题\pic\image-20210116153028378.png)

     > 第二个线程进来尝试加锁, 失败走第二个分支逻辑

     ![image-20210116153225919](E:\learningNotes\面试专题\pic\image-20210116153225919.png)

     非公平锁tryAcquire方法调用的是另一个方法

     ![image-20210116153337004](E:\learningNotes\面试专题\pic\image-20210116153337004.png)

     ![image-20210116153412577](E:\learningNotes\面试专题\pic\image-20210116153412577.png)

     addWaiter

     ![image-20210116154155529](E:\learningNotes\面试专题\pic\image-20210116154155529.png)

     > 第一个节点是哨兵节点, 不是线程节点

     * acquire的三大流程

       ![image-20210116154718841](E:\learningNotes\面试专题\pic\image-20210116154718841.png)

     * tryAcquire

       ![image-20210116154826759](E:\learningNotes\面试专题\pic\image-20210116154826759.png)

     * addWaiter

       ![image-20210116155053568](E:\learningNotes\面试专题\pic\image-20210116155053568.png)

       ![image-20210116154913792](E:\learningNotes\面试专题\pic\image-20210116154913792.png)

     * acquireQueued

       ![image-20210116160506436](E:\learningNotes\面试专题\pic\image-20210116160506436.png)

       ![image-20210116160328988](E:\learningNotes\面试专题\pic\image-20210116160328988.png)

       尝试抢, 抢失败了会被park

   * unlock

     ![image-20210116160721282](E:\learningNotes\面试专题\pic\image-20210116160721282.png)

     ![image-20210116160736040](E:\learningNotes\面试专题\pic\image-20210116160736040.png)

     ![image-20210116160821295](E:\learningNotes\面试专题\pic\image-20210116160821295.png)

     unparkSuccessor

     ![image-20210116161057052](E:\learningNotes\面试专题\pic\image-20210116161057052.png)

     队列中的头节点抢到后, 节点中的线程回去执行任务, 此节点会成为新的哨兵节点, 老的哨兵节点的指针全部断开从而被GC回收



## Spring

IOC + AOP + TX

### spring aop顺序

1. aop的常用注解

   ![image-20210116162522569](E:\learningNotes\面试专题\pic\image-20210116162522569.png)

   

   * Spring4

     正常顺序: 前置通知 ====>  后置通知  ====> 正常返回@AfterReturning

     出现异常的执行顺序:  前置通知 ====>  后置通知  ====>  方法异常@AfterThrowing

   * Spring5

     正常顺序: 前置通知   ====> 正常返回@AfterReturning  ====>  后置通知

     出现异常的执行顺序:  前置通知  ====>  方法异常@AfterThrowing  ====>  后置通知 

### spring循环依赖

1. 面试题

   * spring中的三级缓存?
   * 三级缓存分别是什么?三个map有什么异同吗?
   * 什么是循环依赖?
   * 如何检测循环依赖?
   * 多例的情况下, 循环依赖的问题为什么无法解决?
   * 为什么要用三级缓存?能否关闭三级缓存?

2. 什么是循环依赖

   通常来说, 如果问spring容器内部如何解决循环依赖的问题, 一定是指默认的单例Bean中, 属性相互引用的场景

   ![image-20210116191938464](E:\learningNotes\面试专题\pic\image-20210116191938464.png)

   ![image-20210116192024974](E:\learningNotes\面试专题\pic\image-20210116192024974.png)

3. 两种注入方式对循环依赖的影响

   构造方法注入, set注入

   > 尽量避免构造注入.构造器循环依赖是无法解决的
   >
   > AB循环依赖问题只要A的注入方式是setter且是singleton, 就不会有循环依赖问题

   set注入方式:

   ![image-20210116192827285](E:\learningNotes\面试专题\pic\image-20210116192827285.png)

   ![image-20210116192912871](E:\learningNotes\面试专题\pic\image-20210116192912871.png)

4. spring容器循环依赖报错演示**BeanCurrentlyInCreationException**

   ![image-20210116193129430](E:\learningNotes\面试专题\pic\image-20210116193129430.png)

   ![image-20210116193229150](E:\learningNotes\面试专题\pic\image-20210116193229150.png)

5. spring内部通过三级缓存才能来解决循环依赖问题

   其实就是三个map

   DefaultSingletonBeanRegistry

   ![image-20210116193441084](E:\learningNotes\面试专题\pic\image-20210116193441084.png)

   ​	上述分别是一级缓存, 3级缓存, 2级缓存

   ![image-20210116193520885](E:\learningNotes\面试专题\pic\image-20210116193520885.png)

   > ![image-20210116193548716](E:\learningNotes\面试专题\pic\image-20210116193548716.png)

   ![image-20210116193954963](E:\learningNotes\面试专题\pic\image-20210116193954963.png)

   A/B两个对象在三级缓存中的迁移过程:

   ![image-20210116194231259](E:\learningNotes\面试专题\pic\image-20210116194231259.png)

   ​	详细的调用过程:

   ![image-20210117103759667](E:\learningNotes\面试专题\pic\image-20210117103759667.png)

   ![image-20210117105009448](E:\learningNotes\面试专题\pic\image-20210117105009448.png)

> 一级缓存没有就去二级缓存找, 二级缓存没有就去三级缓存找, 三级缓存有的话就把他移动到二级缓存

* spring是如何解决循环依赖的?

  ![image-20210117105222089](E:\learningNotes\面试专题\pic\image-20210117105222089.png)





## redis

### redis传统5大数据类型的落地应用

1. String

   * 点赞数统计
   * 商品编号, 订单号采用INCR

2. hash

   * 购物车

     ![image-20210117113427595](E:\learningNotes\面试专题\pic\image-20210117113427595.png)

3. list

   * 微信订阅公众号

     ![image-20210117113801379](E:\learningNotes\面试专题\pic\image-20210117113801379.png)

4. set

   * 抽奖小程序

     SPOP key count  随机弹出三个元素

     SRANGE key count 删除元素

   * 微信朋友圈点赞

     sadd  key  member

     srem  key  member

     ![image-20210117114438598](E:\learningNotes\面试专题\pic\image-20210117114438598.png)

   * 好友关注社交关系

     共同关注的人 SINTER

   * qq推荐可能认识的人

     SDIFF s1 s2

5. zset

   ![image-20210117114900517](E:\learningNotes\面试专题\pic\image-20210117114900517.png)

### 分布式锁?有哪些实现方案?谈谈你对redis分布式锁的理解, 删除key的时候有哪些问题?

1. 超卖问题

   高并发情况下售卖商品未对商品加锁导致超卖

2. 解决超卖

   * synchronized

     没有抢到锁就一直等待, 死等

   * ReentrantLock

     tryLock,  设置没抢到锁的等待时间, 没抢到锁放弃或者自旋继续抢

     > 上述的锁只能针对单机情况, 无法针对分布式架构有效

   * redis分布式锁

     set nx ex  设置过期时间要和设置key要同时进行

     问题:

     1. 假设一个线程抢到锁后的同时设置了过期时间10s, 但是其此次执行业务逻辑的时间为12秒, 那么在其干完活之前,redis会自动将锁删除, 此时别的线程会进来, 然后设置一个key及其过期时间, 然后执行业务逻辑,但是第二个线程还没执行完, 此时第一个线程执行完了, 会将第二个线程设置的锁删掉...

     ![image-20210117131926127](E:\learningNotes\面试专题\pic\image-20210117131926127.png)

     > 删除锁之前, 判断一下这个锁对应的value是否是当初自己设置进去的value, 如果是就删除

     2. 如果线程在执行业务是出现异常怎么办?

        try .. finally 保证锁释放

     3. finally块的判断和del操作不是原子性的

        * 用lua脚本

          ![image-20210117133534630](E:\learningNotes\面试专题\pic\image-20210117133534630.png)

        * 不用lua脚本

          redis事务

          ![image-20210117132635691](E:\learningNotes\面试专题\pic\image-20210117132635691.png)

          ![image-20210117132700178](E:\learningNotes\面试专题\pic\image-20210117132700178.png)

          > watch是乐观锁. 如果锁被别人设置过了, 我设置失败

          ![image-20210117133231100](E:\learningNotes\面试专题\pic\image-20210117133231100.png)

     4. 保证redis 锁的过期时间大于业务执行时间(缓存续命)

     5. 集群+CAP对比zookeeper

        redis   =====>  **AP**   ====>   master加锁成功, 不等同步到slave就立即返回告你加锁成功, 如果此时master挂了, 新的master上并没有加锁信息

        zookeeper  =====>  **CP**  ====>   master加锁成功, 同步到slave后告诉你加锁成功

     6. 综上所述, redis集群环境下 set nx 也不OK, 直接上RedLock之Redisson落地实现

        ![image-20210117134820930](E:\learningNotes\面试专题\pic\image-20210117134820930.png)

        ![image-20210117135202797](E:\learningNotes\面试专题\pic\image-20210117135202797.png)

### redis缓存过期淘汰策略?

1. redis缓存大小

   * 一般设置为物理内存的3/4

2. redis缓存淘汰策略

   * 定时删除

     ![image-20210117140521769](E:\learningNotes\面试专题\pic\image-20210117140521769.png)

   * 惰性删除

     ![image-20210117140618208](E:\learningNotes\面试专题\pic\image-20210117140618208.png)

   * 定期删除

     ![image-20210117140844038](E:\learningNotes\面试专题\pic\image-20210117140844038.png)

### redis的LRU算法简介

1. 算法

   ![image-20210117141056263](E:\learningNotes\面试专题\pic\image-20210117141056263.png)

2. 算法总结

   * 两个维度
     * 过期键中筛选
     * 所有键中筛选
   * 四个方面
     * LRU
     * LFU
     * random
     * ttl

3. LRU算法

   最近最久未使用的数据,将其淘汰

   * 实现

     LRU的核心是哈希链表

     ![image-20210117143806255](E:\learningNotes\面试专题\pic\image-20210117143806255.png)

     hashmap + 双向链表

   * LinkedhashMap

   * 手写LRU

     ```java
     package com.interview.study;
     
     import java.util.HashMap;
     import java.util.Map;
     
     public class LruCache {
     
         //map负责查找, 构建一个虚拟的双向链表, 他里面安装的就是一个哥哥node节点, 作为数据载体
     
         class Node<K, V> {
             K key;
             V value;
             Node<K, V> prev;
             Node<K, V> next;
     
             public Node() {
                 this.prev = null;
                 this.next = null;
             }
     
             public Node(K key, V value) {
                 this.key = key;
                 this.value = value;
                 this.prev = null;
                 this.next = null;
             }
         }
     
         class DoubleLinkedList<K, V> {
             Node<K, V> head;
             Node<K, V> tail;
     
             //初始化一个双向链表
             public DoubleLinkedList() {
                 head = new Node<>();
                 tail = new Node<>();
                 head.next = tail;
                 tail.prev = head;
             }
     
             //插入一个元素到队头
             public void addHead( Node<K, V> node) {
                 node.next = head.next;
                 node.prev = head;
                 head.next.prev = node;
                 head.next = node;
             }
     
             //删除节点
             public void removeNode(Node<K, V> node) {
                 node.next.prev = node.prev;
                 node.prev.next = node.next;
                 node.next = null;
                 node.prev = null;
             }
     
             //获取最后一个节点
             public Node getLast() {
                 return tail.prev;
             }
         }
     
         private int capacitySize;
         Map<Integer, Node<Integer, Integer>> map;
         DoubleLinkedList<Integer, Integer> doubleLinkedList;
     
         public LruCache(int capacitySize) {
             this.capacitySize = capacitySize;
             map = new HashMap<>();
             doubleLinkedList = new DoubleLinkedList<>();
         }
     
         public int get(int key) {
             if (!map.containsKey(key)) {
                 return -1;
             }
     
             Node<Integer, Integer> node = map.get(key);
             doubleLinkedList.removeNode(node);
             doubleLinkedList.addHead(node);
     
             return node.value;
         }
     
         //save or update
         public void put(int key, int value) {
             if (map.containsKey(key)) {
                 Node<Integer, Integer> node = map.get(key);
                 node.value = value;
                 map.put(key, node);
                 doubleLinkedList.removeNode(node);
                 doubleLinkedList.addHead(node);
             } else {
                 if (map.size() == capacitySize) {//淘汰
                     Node<Integer, Integer> lastNode = doubleLinkedList.getLast();
                     map.remove(lastNode.key);
                     doubleLinkedList.removeNode(lastNode);
                 }
                 //新增一个节点
                 Node<Integer, Integer> newNode = new Node(key, value);
                 map.put(key, newNode);
                 doubleLinkedList.addHead(newNode);
             }
         }
     }
     
     ```

     

     